{"meta":{"title":"SDN BOLG","subtitle":"","description":"","author":"Simonck","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-08-09T08:05:27.000Z","updated":"2022-08-09T08:07:11.738Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-08-09T08:05:36.000Z","updated":"2022-08-09T08:06:51.099Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"OpenDayLight学习笔记","slug":"OpenDayLight学习笔记","date":"2022-08-09T11:03:33.833Z","updated":"2022-08-12T09:10:16.541Z","comments":true,"path":"2022/08/09/OpenDayLight学习笔记/","link":"","permalink":"http://example.com/2022/08/09/OpenDayLight%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"​ 本文记录了OpenDayLight的学习过程。","text":"​ 本文记录了OpenDayLight的学习过程。 工程名字按照建立顺序命名，规则为Project+名称+序号，使用大驼峰模式。例如：ProjectTest1； 参考文献 OpenDaylight应用开发–基础篇 [ODL技术内幕：架构设计与实现原理](D:\\a研究生资料\\研二\\OpenDayLight\\ODL技术内幕：架构设计与实现原理 (耿兴元) (z-lib.org).epub) Maven仓库搜索(一) Maven仓库搜索(二) 官方Github 基于Oxygen-SR4的ODL框架搭建与开发 获取OpenDayLight项目源码 下载openflowplugin.zip，在父pom文件下安装到本地 mvn -T 1C clean install -DskipTests -Dskip.karaf.featureTest=true -Dmaven.test.skip=true -Dcheckstyle.skip=true -Dmaven.javadoc.skip=true -Dmaven.compile.fork=true 新建OpenDayLight项目骨架软件环境 java version “1.8.0_202” Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537) 其它：Postman、VMware、win11、Intellij Idea、cmd… 建空项目 向标准maven的settings.xml添加odlparent settings.xml内容,添加后的内容为settings-标准版添加odlparentsettings内容.xml; 在E:\\SDN\\OpenDayLight\\ProjectTest1进入cmd，生成项目骨架: mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype -DarchetypeRepository=http://nexus.opendaylight.org/content/repositories/public/ -DarchetypeCatalog=remote -DarchetypeVersion=1.5.1 填写项目信息，填写不当可能导致 Failed to execute goal org.codehaus.mojo:findbugs-maven-plugin:3.0.5:check：错误 copyright：版权方，填公司名称，不能数字开头； copyrightYear、version：默认； groupId：团队名称，建议小驼峰模式； artifactId：项目名，建议小驼峰模式； package、classPrefix：包名、类前缀，建议默认，尤其是classPrefix。 项目文件夹名字为artifactId，进入…\\artifactId运行cmd，安装项目到本地: mvn clean install -DskipTests -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -e 第一个项目：Helloworld参考文献 枫零NET的教程; u_hcy2000的博客 三、OpenDaylight应用基础开发（ODL的Hello World）; 耿兴元老师OpenDaylight应用开发–基础篇; 建立项目ProjectHelloworld1 生成项目骨架、填写项目信息并安装到本地 功能实现 定义YANG文件: 在&#x2F;api&#x2F;src&#x2F;main&#x2F;yang下helloworld.yang文件module{}中添加: rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greeting &#123; type string; &#125; &#125; &#125; 重新安装项目到本地,上述yang模型会在api&#x2F;target&#x2F;generated-sources&#x2F;mdsal-binding&#x2F;org.opendaylight.yang. gen.v1.utn.opendaylight.params.xml.ns.yang.&lt;项目名&gt;.rev&lt;数字&gt;下生成数个类和接口. 进入impl&#x2F;src&#x2F;main&#x2F;java&#x2F;networkGroup&#x2F;impl&#x2F;HelloworldProvider.java下实现代码; 进入impl&#x2F;src&#x2F;main&#x2F;resources&#x2F;org&#x2F;opendaylight&#x2F;blueprint&#x2F;impl-blueprint.xml,在&lt;blueprint&gt;&lt;/blueprint&gt;中添加&lt;odl:rpc-implementation ref=&quot;provider&quot;/&gt;; 重新安装项目,运行E:\\SDN\\OpenDayLight\\ProjectHelloworld1\\helloworld\\karaf\\target\\assembly\\bin\\karaf.bat; 使用Postman，POST方式调用 http://localhost:8181/restconf/operations/helloworld:hello-world； 项目分析​ Helloworld作为OpenDayLight入门的第一个项目，使用了RPC机制来实现功能，需要理解的内容包括： YANG模型和自动生成的工具类、工具接口的对应关系: 是哪些代码实现了读取数据和发送数据的: blueprint是OSGI规范的一部分,ODL使用Apache Blueprint，是XML。 元素 作用 bean 描述创建Java实例的元素，可以指定实例初始化的类名、构造方法、构造方法的入参及属性 service 将bean发布为OSGi Service reference 通过接口名引用一个OSGi Service，可以指定一个特定的属性过滤器 reference-list 通过接口名引用多个OSGi Service，可以指定一个特定的属性过滤器 Global RPC、Routed RPC、Notification的订阅、注册、获取都在blueprint操作。 RPC：Remote Procedure Call基本概念 RPC有两类：Global RPC和Routed RPC 类别 区别 Global RPC 一个节点上只有一个RPC实例会被调用，注册多个实例时第一个注册的生效 Routed RPC 通过不同的RoutedId可以调用不同的RPC实例 如何理解ODL中的RPC：异步的响应模式，单播关系 LLDP2Controller​ 想通过RPC调用openflowplugin项目提供的下发流表功能实现上送LLDP报文到控制器的操作，该功能涉及配置POM文件、获取RPC、注册RPC等内容,在Helloworld项目基础上实现.通过调用别的项目定义好的rpc，是不是就不用自己定义yang文件了？ 把openflowplugin项目依赖进来,在impl&#x2F;pom.xml下&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;中添加openflowplugin-artifacts &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>openflowplugin-artifacts&lt;/artifactId> &lt;version>0.6.1&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> 通过blueprint调用SalFlowService中的add-flow rpc,Global RPC和Routed RPC的获取方式相同： //都是用rpc-service标签 //add-flow rpc找到了,但是为什么调用Id是\"flowService\"?找不到? &lt;odl:rpc-service id=\"flowService\" interface=\"org.opendaylight.yang.gen.v1.urn.opendaylight.flow.service.rev130819.SalFlowService\"/> 建立一个新的bean,规定类的组成: &lt;bean id=\"LLDPToControllerFlowWriter\" class=\"networkGroup.impl.LLDPToControllerFlowWriter\" init-method=\"init\" destroy-method=\"close\"> &lt;argument ref=\"dataBroker\" /> &lt;argument ref=\"flowService\" /> &lt;/bean> 在impl&#x2F;pom.xml下&lt;dependencies&gt;&lt;/dependencies&gt;添加bundle依赖 &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>openflowplugin-api&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>openflowplugin-common&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.opendaylight.controller.model&lt;/groupId> &lt;artifactId>model-inventory&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin.model&lt;/groupId> &lt;artifactId>model-flow-service&lt;/artifactId> &lt;/dependency> 在impl下新建java类.LLDPToControllerFlowWriter，实现相关代码 maven编译，安装到本地 源码分析slf4j（Simple Logging Facade for Java） 不是具体的日志系统，而是为某个日志系统提供服务，它不影响最终用户选择哪种日志系统，方便在不懂代码的情况下切换日志框架 核心是一些API和LoggerFactory类，它本身也带有一个简单的日志框架 简单会用即可 序列化反序列化 序列化： 将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程 需要通过网络传输对象、存储到文件、存储到数据库的时候需要序列化&#x2F;反序列化 JDK 自带的序列化，只需实现 java.io.Serializable接口即可(性能较差,但是ODL部分类使用了该接口) hashCode() hashCode就是对象的散列码，是根据对象的某些信息推导出的一个整数值，默认情况下表示是对象的存储地址。通过散列码，可以提高检索的效率，主要用于在散列存储结构中快速确定对象的存储地址 和equals()、toString()可以看做Java类的标配 字段（Field） java反射– Field 用法实践 简单理解就是：我们可用通过Field类对类或对象的field进行动态操作 **field在ODL\\Java中的作用是什么?**SDN更换报文字段的功能是否是基于Field实现的？ FlowBuilder org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table下的类,功能是构建流表Flow openflow1.3流表项构成: public class FlowBuilder implements Builder&lt;Flow> &#123; private Long _bufferId; private String _containerName; private FlowCookie _cookie; //由控制器选择的不透明数据值。控制器用来过滤流统计数据、流改变和流删除,但处理数据包时不能使用 private FlowCookie _cookieMask;//?? private FlowModFlags _flags; private String _flowName; private Integer _hardTimeout; //硬超时时间 private FlowId _id; private Integer _idleTimeout; //空闲超时时间 private Instructions _instructions; //指令集,动作或流水线处理 private FlowKey _key; private Match _match; private Long _outGroup; private BigInteger _outPort; private Integer _priority; private Short _tableId; private Boolean _barrier; private Boolean _installHw; private Boolean _strict; OpenFlow协议超时机制简介: 硬超时hard timeout:当该流表项的存在时间超过了预设置的硬超时，流表项就会被交换机从流表中移除。即流表项从交换机移除的绝对时间 空闲超时idle timeout:如果连续idle timeout时间内都没有匹配到这条流表,则交换机会主动将该流表项从流表中移除 MatchBuilder org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow用于构建匹配字段 openflow1.3支持的匹配字段包括: Bug收集 ​","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"ODL","slug":"ODL","permalink":"http://example.com/tags/ODL/"}]},{"title":"工具Utils","slug":"工具Utils","date":"2022-08-09T10:48:22.391Z","updated":"2022-08-12T09:05:32.606Z","comments":true,"path":"2022/08/09/工具Utils/","link":"","permalink":"http://example.com/2022/08/09/%E5%B7%A5%E5%85%B7Utils/","excerpt":"​ 本文记录了软件学习过程中用到的工具类知识点，比如数据交换格式、软件安装、环境配置、某个特殊类等。","text":"​ 本文记录了软件学习过程中用到的工具类知识点，比如数据交换格式、软件安装、环境配置、某个特殊类等。 JSON [[图灵程序设计丛书].JSON必知必会](https://pan.baidu.com/s/1UoHP8BiumEt70aSVyhv7dQ提取码：3ir5 )：基础语法1-4章 XML [XML入门经典（第5版）](https://pan.baidu.com/s/1l8uOjScZA3tFntH4UTZi-A提取码：gmy9 )基础语法：2-4章 [XML基础教程（第二版）](https://pan.baidu.com/s/1PLCv0MfDOhE7eYo9OXAykg提取码：qqxx [) W3school:xml XML 教程 &lt;!--xml序言+独立声明--> &lt;!--注意linux还是Windows格式的换行符--> &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> &lt;!--创建元素的方式--> &lt;!--标准元素,有内容--> &lt;myelement>code&lt;/myelement> &lt;!--自封闭元素,没有内容--> &lt;myelement/> &lt;!--四种命名方式--> &lt;!--大驼峰--> &lt;MyElement/> &lt;!--小驼峰--> &lt;myElement/> &lt;!--下划线--> &lt;my_element/> &lt;!--连字符--> &lt;my-element/> &lt;!--一个文档只能有一个根元素--> &lt;root> &lt;!--元素中可以添加属性:属性就是(名称-值)--> &lt;myelement myfirstattribute=\"one\" mysecondattribute='two' mythirdattribute=' '>&lt;/myelement> &lt;!--元素和属性均可包括文本--> &lt;myelement>Here is a test&lt;/myelement> &lt;!--元素和属性都可以用来包装数据--> &lt;!--元素--> &lt;user> &lt;firstname>Yu-Ang&lt;/firstname> &lt;lastname>ZHU&lt;/lastname> &lt;/user> &lt;!--属性--> &lt;user firstname=\"Yu-Ang\" lastname=\"ZHU\" /> &lt;user firstname=\"Yu-Ang\" lastname=\"ZHU\">&lt;/user> &lt;!--处理指令--> &lt;?xml-stylesheet type=\"text/xsl\" href=\"appUsers.xslt\"?> &lt;!--CDATA节,允许在xml文件中插入纯文本--> &lt;!--格式: &lt;![CDATA[文本内容]]> --> &lt;user> &lt;![CDATA[这里写的内容会被当做纯文本处理]]> &lt;/user> &lt;!--通过向元素中添加特殊的属性来决定如何处理空白符--> &lt;!--保留空白符--> &lt;user xml:space=\"preserve\"/> &lt;!--默认处理空白符--> &lt;user xml:space=\"default\"/> &lt;!--命名空间：理解为Java中的package,大小写敏感--> &lt;!--命名空间：建议使用URL或者URN命名规范，这两个合称URI--> &lt;!--URL--> [Scheme]://[Domain][:Port]/[Path]?[QueryString]#[FragmentId] &lt;!--URN--> urn:[namespace identifier]:[namespace specific string] &lt;!--声明命名空间的方法一：默认命名空间,希望整个文档都属于这个空间--> &lt;root xmlns = \"http://wrox.com/namespace/app/config\"> &lt;firstname>Yu-Ang&lt;/firstname> &lt;lastname>ZHU&lt;/lastname> &lt;/root> &lt;!--root元素中的所有子元素都属于这个命名空间,但是属性不属于这个空间--> &lt;!--即:默认命名空间仅针对元素--> &lt;!--给属性分配命名空间需要显示定义,即前缀名,声明命名空间的方法二--> &lt;!--给命名空间一个前缀名xx,并且把元素分配给该空间--> &lt;xx:user xmlns:xx = \"http://wrox.com/namespace/app/config/xx\"> &lt;firstname>Yu-Ang&lt;/firstname> &lt;lastname>ZHU&lt;/lastname> &lt;/xx:user> &lt;!--把属性也分配给命名空间--> &lt;user xx:firstname=\"Yu-Ang\" xx:lastname=\"ZHU\" /> &lt;user xx:firstname=\"Yu-Ang\" xx:lastname=\"ZHU\">&lt;/user> &lt;!--使用&#123;URI&#125;+元素名唯一标记一个元素--> &#123;http://wrox.com/namespace/app/config&#125;root &lt;/root> Maven [动力节点：maven入门](https://pan.baidu.com/s/10avLNviwoYM7id_1OAQwPQ提取码：y6no [) 动力节点：maven视频","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"}]},{"title":"YANG语言","slug":"YANG语言","date":"2022-08-09T10:48:22.389Z","updated":"2022-08-10T10:03:21.828Z","comments":true,"path":"2022/08/09/YANG语言/","link":"","permalink":"http://example.com/2022/08/09/YANG%E8%AF%AD%E8%A8%80/","excerpt":"​ 本文记录了学习SDN过程中涉及的YANG语言的知识点,以及ODL是如何使用YANG语言的.","text":"​ 本文记录了学习SDN过程中涉及的YANG语言的知识点,以及ODL是如何使用YANG语言的. 参考文献 RFC6020 - YANG语言标准中文 ODL技术内幕：架构设计与实现原理 Restful和Restconf REST（Representational State Transfer，表述性状态转移）是一种软件设计风格，不是一个标准，许多web是基于REST风格设计的。（1.资源静态，动作清晰；2.无状态设计；3.前后端分离API；） Restful接口是遵循REST设计风格的接口，没有标准要求； Restconf接口是既遵循REST设计风格，又遵循IETF制定的RFC8040标准的接口，有明确的定义和设计规范，基于HTTP协议，用于访问YANG语言定义的数据。比Netconf语言简洁、灵活。 YANG基础概念 schema tree:模式树,data tree:数据树; 专门用于描述数据的语言; YANG语言使用module\\submodule构建数据模型; 树形结构; ODL用YANG抽象数据模型,包括项目YANGTools等; 基础语法定义module和submodule 一个module能包含任意数量的submodules，但是每个submodule只能属于一个module moudle还包含一些命名空间、前缀 //这些是module的基本信息,包括import的其它module,本module的版本、修改时间、简称的前缀等 module sal-flow &#123; namespace \"urn:opendaylight:flow:service\"; prefix flow; import yang-ext &#123;prefix ext; revision-date \"2013-07-09\";&#125; import opendaylight-inventory &#123;prefix inv;revision-date \"2013-08-19\";&#125; import opendaylight-flow-types &#123;prefix types;revision-date \"2013-10-26\";&#125; import opendaylight-group-types &#123;prefix group-type;revision-date \"2013-10-18\";&#125; import opendaylight-meter-types &#123;prefix meter-type;revision-date \"2013-09-18\";&#125; import flow-capable-transaction &#123;prefix tr; revision-date \"2015-03-04\";&#125; import flow-errors &#123;prefix error; revision-date \"2013-11-16\";&#125; description \"Openflow flow management.\"; revision \"2013-08-19\" &#123; description \"Initial revision of flow service\"; &#125; YANG四种节点类型 leaf：只能包含一个值，没有子节点； //一个名字叫host-name的leaf类型的节点 //节点包含string类型的数据 //描述信息是\"Hostname for this system\" leaf host-name &#123; type string; //必选 description \"Hostname for this system\"; &#125; leaf-list：一系列的leaf节点； //一系列leaf节点,这些节点都是用来domain-search的 //节点都包含string类型数据 //相当于数组 leaf-list domain-search &#123; type string; description \"List of domain names to search\"; &#125; container:没有值,专门用于把相关的节点归纳到一个subtree下面,可以包括任何类型\\任何数量子节点: //container类型的system节点包含container类型的login节点 //container类型的login节点把leaf类型 message节点组成了一棵子树 container system &#123; container login &#123; leaf message &#123; type string; description\"Message given at start of login session\"; &#125; &#125; &#125; list:由一个key的leaf节点唯一确定,能定义多种key leafs,能包含任意类型\\任意数目子节点: //名为user的list,由名为name的leaf节点唯一确定 //user里面还包括其他leaf list user &#123; key \"name\"; leaf name &#123; type string; &#125; leaf full-name &#123; type string; &#125; leaf class &#123; type string; &#125; &#125; 上述四种节点可以组成简单的示例module: // Contents of \\\"acme-system.yang\\\" module acme-system &#123; namespace \\\"http://acme.example.com/system\\\"; prefix \\\"acme\\\"; organization \\\"ACME Inc.\\\"; contact \\\"joe@acme.example.com\\\"; description \\\"The module for entities implementing the ACME system.\\\"; revision 2007-06-09 &#123; description \\\"Initial revision.\\\"; &#125; container system &#123; leaf host-name &#123; type string; description \\\"Hostname for this system\\\"; &#125; leaf-list domain-search &#123; type string; description \\\"List of domain names to search\\\"; &#125; container login &#123; leaf message &#123; type string; description\"Message given at start of login session\\\"; &#125; list user &#123; key \\\"name\\\"; leaf name &#123; type string; &#125; leaf full-name &#123; type string; &#125; leaf class &#123; type string; &#125; &#125; &#125; &#125; &#125; YANG定义RPC(Remote Procedure Call) 定义操作名字，输入参数，和输出参数: //定义远程调用activate-software-image //输入的一个string类型的 image-name //期望得到一个string类型的输出status rpc activate-software-image &#123; input &#123; leaf image-name &#123; type string; &#125; &#125; output &#123; leaf status &#123; type string; &#125; &#125; &#125; Helloworld.yang被解读为： //helloworld模块中定义了一次名为hello-world的rpc调用 //输入是string类型的name //输出是string类型的greeting //能够与Postman请求的结果对应上 module helloworld &#123; yang-version 1.1; namespace \"urn:opendaylight:params:xml:ns:yang:helloworld\"; prefix \"helloworld\"; revision \"2017-08-30\" &#123; // TODO change revision to date of model creation description \"Initial revision of helloworld model\"; &#125; rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greeting &#123; type string; &#125; &#125; &#125; YANG定义Notification notifaction是误拼,写文件时千万注意 notification的定义和container\\grouping差不多,不像RPC中有input和output,应该是跟notification的运行机制有关系 notification flow-added &#123; status deprecated; uses tr:transaction-metadata; leaf flow-ref &#123; type types:flow-ref; &#125; uses node-flow; uses tr:transaction-aware; &#125; YANG自定义新类型typedef typedef声明定义了一个新的type， 该自定义type可以在module内部，包含该module的modules或submodules，以及导入该module的其它modules使用 // flow-table-ref 是定义的新类型的名字 typedef flow-table-ref &#123; description \"Openflow table identifier\"; type instance-identifier; // instance-identifier是YANG的基本类型:References a data tree node &#125; 例如inet:port-number\\inet:ip-address都是自定义的类型 可重用节点集合Grouping grouping声明了一个可重用的集合,定以后在引用的位置通过”uses”实例化 //定义名为node-flow-removed的 grouping //里面添加了两个leaf // grouping node-flow-removed &#123; description \"Flow removed message structure.\"; leaf node &#123; // TODO:: replace with inv:node-context-ref ext:context-reference \"inv:node-context\"; type inv:node-ref; &#125; leaf flow-table &#123; type flow-table-ref; &#125; uses types:flow-mod-removed; &#125; //在container中引用grouping container peer &#123; container destination &#123; uses node-flow-removed; &#125; &#125; grouping可以在引用时被重新定义 uses只有一个参数,应该是grouping的名字, //标准用法 type是其他yang文件的简称,以前缀的形式出现 uses types:flow; //参数带双引号是什么意思?grouping名字可以带双引号? uses \"inv:node-context-ref\"; status声明 “status”声明的参数是一个字符串，是“current”，“deprecated”或者“obsolete”中的一个 “current”意味着该定义在当前是有效的 “deprecated”表示该定义已经被废弃，不过保证在暂时在后续的实现中支持该定义，以保证向前兼容 “obsolete”意味着这个定义已经被完全废弃，不应该再使用了 choice与case “choice”和”case”用于声明互不相容不能同时出现的节点，”choice”声明包含了多个”case” 每个”case”声明都可能包含多个节点，但是每个节点都应该只在一个”case”中出现 //可以理解为object-reference中有三个选项 //这三个选项只能选一个,不能同时生效 grouping node-error-reference &#123; description \"Error message binding - to which source type the error belongs.\"; choice object-reference &#123; case flow-ref&#123; leaf flow-ref &#123; type types:flow-ref; &#125; &#125; case group-ref&#123; leaf group-ref &#123; type group-type:group-ref; &#125; &#125; case meter-ref&#123; leaf meter-ref &#123; type meter-type:meter-ref; &#125; &#125; &#125; &#125; include与import include用于引用其他submodule定义的数据 import用于引入其他module定义的数据 include acme-types; import yang-ext &#123;prefix ext; revision-date \"2013-07-09\";&#125; YANG在ODL中的实现元素命名QName（Qualified Name，限定名） 来源于XML，格式是命名空间namespace：元素名localName，例：xsl:template ODL类似于XML，但多了revision字段，即namespace、localName和revision（修订版本），其中namespace和revision标识一个YANGmodule，可以分为locallocalName和QNameModule ODL在org.opendaylight.yangtools.yang.common中定义 QName由QName、QNameModule与Revision类组成 QName的比较、创建…. 数据树的索引YangInstanceIdentifier YANG中有instance-identifier用来唯一标识数据树中某个节点,ODL用YangInstanceIdentifier类实现 是一个分层的、基于内容的、唯一的标识符，用来对数据树中数据项的寻址，代表了数据树中某个节点的路径 语法格式使用的是XPath的简化格式的子集,ODL用Path接口表示,org.opendaylight.yangtools.concepts.Path YangInstanceIdentifier类实现Path接口,可以说YangInstance-Identifier类就是表示了数据树中的节点访问路径的定义,org.opendaylight.yangtools.yang.data.api.YangInstanceIdentifier YangInstanceIdentifier由PathArgument(路径的参数)组成,一组有序的PathArgument列表构成一条访问路径 YangInstanceIdentifier的比较、创建…. 数据节点抽象定义NomalizedNode NormalizedNode类作为所有数据节点的基础抽象,即定义一个通用的接口来统一表示上述YANG节点类型","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"YANG","slug":"YANG","permalink":"http://example.com/tags/YANG/"}]}],"categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"ODL","slug":"ODL","permalink":"http://example.com/tags/ODL/"},{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"},{"name":"YANG","slug":"YANG","permalink":"http://example.com/tags/YANG/"}]}