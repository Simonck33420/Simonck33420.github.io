{"meta":{"title":"SDN BOLG","subtitle":"","description":"","author":"Simonck","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2022-08-09T08:05:27.000Z","updated":"2022-08-09T08:07:11.738Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-08-09T08:05:36.000Z","updated":"2022-08-09T08:06:51.099Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Openflowplugin","slug":"Openflowplugin","date":"2022-09-01T01:42:36.374Z","updated":"2022-09-01T01:40:34.330Z","comments":true,"path":"2022/09/01/Openflowplugin/","link":"","permalink":"http://example.com/2022/09/01/Openflowplugin/","excerpt":"","text":"Openflowplugin​ 本文记录了Openflowplugin项目的阅读和解析. 基础概念 参考文献 OpenflowPlugin源码分析(一至八)","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"Openflowplugin","slug":"Openflowplugin","permalink":"http://example.com/tags/Openflowplugin/"}]},{"title":"L2switch","slug":"L2switch","date":"2022-09-01T01:42:36.370Z","updated":"2022-09-01T01:42:20.365Z","comments":true,"path":"2022/09/01/L2switch/","link":"","permalink":"http://example.com/2022/09/01/L2switch/","excerpt":"","text":"L2switch​ 本文记录了对标准L2switch和私有L2switch的阅读和解析. 基础概念 项目目的：基于MD-SAL架构实现基本的2层交换功能,包括对早先版本的重构,适合学习MD-SAL架构 参考文献: L2switch源码分析（上） L2switch源码分析（下） 项目模块： 模块名 作用 Packet Handler 解码上送到控制器的报文并正确分发 Loop Remover 消除网络中的环路 Arp Handler 处理ARP报文 Address Tracker 学习网络中设备的IP地址和MAC地址,把地址存入datastore中inventory对应节点 Host Tracker 跟踪网络中的主机的拓扑位置 L2Switch Main 根据网络流量下发流表,依赖于上边模块的处理结果 Address Tracker(未改动)/*AddressObservationWriter:根据索引NodeConnectorRef添加mac地址和ip地址*/ public void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef) &#123; return; &#125; /*AddressObserverUsingArp:处理收到的ARP包,校验后调用addressObservationWriter.addAddress写入*/ public void onArpPacketReceived(ArpPacketReceived packetReceived) &#123; RawPacketFields rawPacket = null; EthernetPacket ethernetPacket = null; ArpPacket arpPacket = null; addressObservationWriter.addAddress(ethernetPacket.getSourceMac(), IpAddressBuilder.getDefaultInstance(arpPacket.getSourceProtocolAddress()), rawPacket.getIngress()); &#125; /*AddressObserverUsingIpv4:处理IPv4包*/ /*AddressObserverUsingIpv6:处理IPv6包*/ /*AddressTrackerProvider:一般是AddressTracker模块的入口,初始化该模块的功能,初始化过程在Init()中,这个模块涉及notification的发布\\侦听*/ Arp Handler(未改动)​ 项目中由于系统的ip\\mac相对变化不大,所以实际项目中不太需要处理ARP,使用的相关逻辑是私有的,不是标准的,保留这个模块是为以后做准备(删除或扩展).这里最重要的是inventory.InventoryReader方法,私有的处理datastore的方法就是根据它改的,加了功能和过滤. package 内容 core ArpHandlerProvider\\ ArpPacketHandler\\ PacketDispatcher\\ ProactiveFloodFlowWriter flow InitialFlowWriter inventory InventoryReader core: /**ArpHandlerProvider:初始化ArpHandler模块(入口),关闭ArpHandler模块 主要关注Init(),这里判断了ARP是Proactive模式还是Reactive模式(主动与被动模式) Proactive模式主动下发洪泛ARP的流表,Reactive模式下发把ARP报文上送至控制器的流表 前者调用 ProactiveFloodFlowWriter 后者调用InitialFlowWriter 再创建好读datastore、分发包、处理包、notification等对象*/ /**ArpPacketHandler:处理送上来的ARP报文 类成员包括一个PacketDispatcher的对象,用来发包 主要成员方法是*/ public void onArpPacketReceived(ArpPacketReceived packetReceived) &#123; //收到的包经过校验计算、处理后,调用PacketDispatcher把包发出去 packetDispatcher.dispatchPacket(packetReceived.getPayload(), rawPacket.getIngress(), ethernetPacket.getSourceMac(), ethernetPacket.getDestinationMac()); &#125; /**PacketDispatcher:把包发送出去,作为一个功能类定义了几个成员方法,典型的有*/ //把来自ingress节点的载荷payload发出去,按照源mac和目的mac的关系,调用洪泛或单播方法 public void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac) &#123; &#125; /**ProactiveFloodFlowWriter:用于L2Switch的proactive模式。在这种模式下， 造成洪泛的流表自动写入每个交换机，发送到控制器的(traffic)流量更少。*/ flow: /**InitialFlowWriter:给所有交换机下发将ARP数据包发送到控制器的流表, 与core.ProactiveFloodFlowWriter相对,有新交换机上线时会自动识别并下发*/ inventory： /**InventoryReader:用于读datastore数据 详解见packethandler.xx.control.inventory.InventoryReader*/ Host Tracker(有小改动)主机上线,处理,完成之后把结果告诉私有模块. Packet Handler(主要功能)​ Packet Handler负责处理控制器涉及的大部分报文,私有功能的逻辑主要在这里定义.相比标准结构,增加了control、icfp两个文件夹,共有decoder(解码器)文件夹和PacketHandlerProvider类,重点关注control和icfp文件夹,以及私有项目对blueprint的改动,对pom.xml文件的改动. decoder(未改动): package\\class 作用 utils 解码器的工具包 AbstractPacketDecoder 解码抽象类，所有解码器必须继承实现其中方法 ArpDecoder 解码ARP报文 EthernetDecoder 解码以太网帧 IcmpDecoder 解码Icmp报文 Ipv4Decoder 解码Ipv4报文 Ipv6Decoder 解码Ipv6报文,在私有系统中暂时不涉及 PacketHandlerProvider（未改动）：/**PacketHandlerProvider:模块的入口*/ public class PacketHandlerProvider &#123; private static final Logger LOG = LoggerFactory.getLogger(PacketHandlerProvider.class); //不可变集合ImmutableSet ImmutableSet&lt;AbstractPacketDecoder> decoders; //引入Notification服务,在blueprint中引入,是否实现Notification功能,后续实现 private final NotificationProviderService notificationService; //构造器,有参 public PacketHandlerProvider(final NotificationProviderService notificationService) &#123; this.notificationService = notificationService; &#125; //初始化模块,new一堆解码器 public void initiateDecoders() &#123; decoders = new ImmutableSet.Builder&lt;AbstractPacketDecoder>() .add(new EthernetDecoder(notificationService)) .add(new ArpDecoder(notificationService)).add(new Ipv4Decoder(notificationService)) .add(new Ipv6Decoder(notificationService)).add(new IcmpDecoder(notificationService)).build(); LOG.info(\"PacketHandler initialized.\"); &#125; //侦测有解码器对象在,遍历关闭 public void closeDecoders() throws Exception &#123; if (decoders != null &amp;&amp; !decoders.isEmpty()) &#123; for (AbstractPacketDecoder decoder : decoders) &#123; decoder.close(); &#125; &#125; LOG.info(\"PacketHandler (instance &#123;&#125;) torn down.\", this); &#125; &#125; blueprint:packet-handler.xml&lt;!--标准l2switch中的blueprint很简洁,类只注册了入口PacketHandlerProvider,服务只引入了notificationService--> &lt;reference id=\"notificationService\" interface=\"org.opendaylight.controller.sal.binding.api.NotificationProviderService\" /> &lt;bean id=\"packetHandler\" class=\"org.opendaylight.l2switch.packethandler.PacketHandlerProvider\" init-method=\"initiateDecoders\" destroy-method=\"closeDecoders\"> &lt;argument ref=\"notificationService\" /> &lt;/bean> &lt;!--私有项目中对应的blueprint由于增加了功能,注册了新的类,引入了新的服务,略写列在下面--> &lt;reference id=\"dataBroker\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\"odl:type=\"default\" /> &lt;odl:rpc-service id=\"salFlowService\" interface=\"org.opendaylight.yang.gen.v1.urn.opendaylight.flow.service.rev130819.SalFlowService\"/> &lt;odl:rpc-service id=\"packetHandlerService\" interface=\"org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.PacketProcessingService\"/> &lt;bean>ControlServiceIml&lt;/bean> &lt;bean>MyOdlProvider&lt;/bean> pom.xml:增加了依赖项​ 增加了依赖项,主要是openflowplugin、snmp、json等方面. control(增加): package\\class 作用 config 存放系统的配置,提供三种配置Link、Node、Rule，以集合的形式存在总配置对象ConfObject中 entity(实例) 类似于工具类,放了一些功能的实例类,但是大部分代码由于各种原因已经不适用了,保留是因为还没来得及删除或留待以后拓展 flow 包括下发流表的单例,创建\\下发控制器到控制器的初始流表 inventory 保存信息,创建保存信息的数据结构,以及读取ODL内存的功能类 listener 创建了各种消息的侦听器 pathfinding processer service util ControlProvider CustomPacketDispatch 自定义的分发包方法 /**Conf:*/ /**在三种配置的上层,建立了三个集合存放不同的配置对象*/ public class ConfObject&#123; public int outer_dpid=-1;//初始化值,-1无效 public List&lt;LinkConfInfo> link=new ArrayList&lt;>();//存放连接配置 public String controller; public HashMap&lt;String,NodeConfInfo> nodeConfInfo=new HashMap&lt;>();//存放节点配置 public List&lt;RuleConfInfo> rules=new ArrayList&lt;>();//存放规则配置 &#125; /**下面三类配置类都比较简单,就是成员变量+构造器*/ public class LinkConfInfo&#123; public int port; public String type; public String channel; public int interval;//端口之间同步的间隔 /**构造器*/ &#125; public class NodeConfInfo&#123; public String node_level; public String node_num; /**构造器*/ &#125; /**所谓规则Rule就是从这个口到那个口\\这个地址到那个地址走哪个信道?优先级多少?之类的可配置的选项*/ public class RuleConfInfo&#123; public String source_ip; public String source_mac; public int des_port_num; public int protocol_type; public int priority; public int channel; /**构造器*/ &#125; /**entity: ------flow:早期用于下流表的代码,由于改需求已经不用了,暂时没删除,供参考 ------highlight:控制拓扑有流量时高亮功能的代码,,现在是由自己的前端控制,已经不用了,供参考 ------host:存放外网交换机的dpid和mac,包括源和目的,暂时用不上 ------internal:处理车内终端和链接状态 ------multicast:(多播) ------path:包括路径对象,和路径的配置等等 ------rule:现在用其他方法配规则,已经不用了 ------Narrowband.java(窄带):读窄带端机的信息,ip\\掩码\\下一跳等 */ /**flow:包含4*xx.java*/ //自定义动作项 public class CustomActionItem&#123; public int out_put; /**构造器*/ &#125; //自定义匹配项 public class CustomMatchItem&#123; public String s_ip; public String d_ip; public String s_mac; public String d_mac; public int protocol_num = -1; public int l4_source_num= -1; public int l4_destination_num = -1; /**标准配置*/ toString(); equals(); hashCode(); /**构造器*/ &#125; //说明了一条流表的基本状态 public class FlowObject&#123; public FlowStatus flowStatus; public boolean chao_duan_bo=false; public List&lt;Path> in_car_paths=new ArrayList&lt;>();//车内路径 public List&lt;Path> external_paths=new ArrayList&lt;>();//车间路径 public boolean onSameCar=false; public int onSameCar_dpid = -1; //每个交换机对应一个Action列表 public HashMap&lt;Integer,List&lt;CustomActionItem>>action_map=new HashMap&lt;>(); public List&lt;Integer> rule_list=new ArrayList&lt;>(); public void clear()&#123;&#125; &#125; // public enum FlowStatus&#123; NO_ARP,//无arp响应 NO_BETWEEN_PATH,//无车间路径 IN_CAR_FLOW,//车内的流表 BETWEEN_FLOW//车间的流表 &#125; /**flow: ----FlowWriter.java:下发流表的功能类,调用salFlowService服务，包括创建、下发、删除流表、创建动作和指令等 ----InitialC2CFlowWriter.java:创建系统启动时下发的流表,C2C:一个控制器到另一个控制器 */ public class FlowWriter&#123; //成员对象 private static final FlowWriter instance=new FlowWriter();//饿汉单例,别人不能new它,只能调用它 private SalFlowService salFlowService ; //构造器 private FlowWriter()&#123;&#125;//饿汉单例 //getter setter方法 //成员方法 addFlow();/**包括:_inCar,_CHAODUANBO,_multicast,SegmentedPath(分段路径), */ createFlow();/**包括:CHAODUANBO,_multicast,remove*/ removeFlow();/***/ createInstructions();/***/ createAction();/**SetFieldDestinationMacAddress,OutPut,*/ getmaskIP();//处理掩码和IP &#125; public class InitialC2CFlowWriter implements DataTreeChangeListener&lt;node>&#123; //成员对象 private static final String FLOW_ID_PREFIX= \"l2switch-\"; private static final int C2C_ETHER_TYPE=2320;//私有的以太网类型,0x0910 private final ExecutorService initialFlowExecutor=Executors.newCachedThreadPool(); private final SalFlowService salFlowService ; private short flowTableId=0; private int flowPriority = 100; private int flowIdleTimeout = 0; private int flowHardTimeout = 0; private final AtomicLong flowIdInc=new AtomicLong(); private final AtomicLong flowCookieInc=new AtomicLong(0x2b0000000000000L); //构造器 public InitialC2CFlowWriter(SalFlowService salFlowService ); //成员方法 onDataTreeChanged(Collection&lt;DataTreeModification&lt;Node>> changes) ; //内部成员类 public class InitialFlowWriterProcessor implements Runnable&#123; addInitialFlows(); getTableInstanceId(); getFlowInstanceId(); createControllerToControllerFlow(); createDefaultFlow(); getSendToControllerAction(); writeFlowToController(); &#125; &#125; /**inventory: ------FlowDB: 保存路径,包括源和目的在同一台车或不在同一台车,由于改需求,已经不用了,不需要保存路径了 ------InternalDB:给一台车本身的大部分配置都建好集合,从配置文件或其它渠道拿到数据后再存到里面 ------InventoryReader:参考arphandler.inventory.InventoryReader写的读取ODL内存的功能类,还命名为InventoryReader,变化不大 ------RuleDB:保存规则,配置信息等,现在已经不用这种方式配置规则了,只保留了ALL_CHANNEL_LIST,写死5种信道 */ /**FlowDB: */ public class FlowDB&#123; //源和目的在同一台车,保存转发端口就可以 updateInCarFlowMap_SameCar(int dpid,String s_ip,String d_ip,int output_port); //源和目的不在一个车内,需要保存路径计算的结果,就是一个List集合 updateInCarFlowMap_Path(String s_ip,String d_ip,List&lt;Path> paths); &#125; /**InternalDB: */ public class InternalDB&#123; /**成员对象*/ //new一个空的配置对象 public static ConfObject confObject = null; //外部交换机的dpid public static int EXT_SWITCH_DPID = -1; public static HashMap&lt;Integer,Boolean> EXT_NODE_PORT_STATUS=new HashMap&lt;>(); //网关 //车间连接端口:从配置文件中读取车是通过哪些端口连起来的 //端机MAC: //窄带端机都挂载在哪个交换机下面 //有哪些车内交换机:内网\\外网交换机都读 //车内主机mac: //本车交换机mac: //本车的角色配置: &#125; /**InventoryReader: */ public class InventoryReader implements DataTreeChangeListener&lt;DataObject>&#123; /**成员对象*/ private static final Logger LOG=LoggerFactory.getLogger(InventoryReader.class); private final Databroker databroker; private final HashMap&lt;String,List&lt;NodeConnectorRef>> controllerSwitchConnectors; private final HashMap&lt;String,List&lt;NodeConnectorRef>> switchNodeConnectors; private final List&lt;Registration> listenerRegistrationList = new CopyOnWriteArrayList&lt;>(); private volatile boolean refreshData = false;//使用volatile关键字会强制将修改的值立即写入主存,任意线程修改了这个值,对其它线程立即可见 private final long refreshDataDelay = 20L; private volatile boolean refreshDataScheduled = false; private final ScheduledExecutorService nodeConnectorDataChangeEventProcessor=Executors.newScheduledThreadPool(1); /**构造器*/ /**getter、setter方法*/ public void setRefreshData(boolean refreshData); /**成员方法*/ public void registerAsDataChangeListener(); public void onDataTreeChanged(); public void close(); //读取data tree以查找有关节点node和节点连接器NodeConnectors的信息。为给定交换机创建NodeConnector的List集合。还确定每个NodeConnector的STP状态。 public void readInventory(); &#125; /**RuleDB: */ public class RuleDB&#123; /**成员对象*/ public static List&lt;Integer> ALL_CHANNEL_LIST = Stream.of(4,3,2,1,0).collect(Collectors.toList()); &#125; /**listener: ------ARPlistener: ------C2CPacketListener: ------HostInfoListener: ------LldpListener: ------SegmentedPathCalculationListener: ------TopoChangeNotificationListener: */ /**ARPlistener: */ /**pathfinding: ------ ------ */ /**processor： ------ ------- */ /**service: ------ ------ ------ */ /**util: ------ ------ ------ ------ ------ */ /**ControlProvider: */ public class ControlProvider&#123; /**成员对象*/ private final DataBroker dataService； private final SalFlowService salFlowService； private final NotificationProviderService notificationService； private final PacketProcessingService packetProcessingService； public static int PATH_MODE = 1；//0:源节点计算整条路径 1:各节点分别计算 //多态写法 private Registration initialFlowWriterListenerReg; private Registration arpHandlerRegistration; private Registration unicastArpHandlerRegistration; private Registration ipv4HandlerRegistration; private Registration c2cListenerRegistration; private Registration lldpListenerRegistration; private Registration segmentedPathProcessorRegistration; private Registration icfpListenerReg; public static Icfpv2Target icfpv2Target; /**构造器*/ /**成员方法*/ //从文件中读取系统配置 public void readconf()&#123; &#125; public void init() throws IOException&#123;&#125; &#125; /**CustomPacketDispatcher: 自定义的分发包方法,不同需求的发包方法都定义在这 */ public class CustomPacketDispatcher&#123; /**成员对象*/ private InventoryReader inventoryReader; private PacketProcessingService packetProcessingService; /**getter,setter方法*/ /**没写构造器,默认是无参构造器*/ /**成员方法*/ //发送包，调用了底层的TransmitPacketInput，以及Future public void sendPacketOut(byte[] payload,NodeConnectorRef ingress,NodeConnectorRef egress)； public void sendData2Port(byte[] data,String node_id,int outport_port); public void floodArpRequest(String s_ip,String d_ip,String s_mac,NodeConnectorRef nodeConnectorRef); public void sendArpRequest(String s_ip,String d_ip,String s_mac,String nodeId,List&lt;InternalLink> links,NodeConnectorRef origIngress,boolean external); &#125; icfp(增加): package\\class 作用 icsp igmp master timer utils","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"L2switch","slug":"L2switch","permalink":"http://example.com/tags/L2switch/"}]},{"title":"Bug收集","slug":"Bug收集","date":"2022-09-01T01:42:36.369Z","updated":"2022-09-01T01:36:43.154Z","comments":true,"path":"2022/09/01/Bug收集/","link":"","permalink":"http://example.com/2022/09/01/Bug%E6%94%B6%E9%9B%86/","excerpt":"","text":"Bug收集​ 本文整理收集了调试过程中遇到的Bug和对应的解决方法，供调试时参考. 不同package下同名方法供需错误​ 在ODL中，由于版本更迭，许多不同名字的package中包括了相同名字的方法，在导入ODL包的过程中就有可能出现下图的错误，简单解释就是这里需要白字package中的方法（Required type）但是我们却导入了红字package中的方法（Provided）;唯一的解决办法:就是把涉及的package梳理清楚，把引用关系对应上，在LLDP2Controller实验中出现了这个错误,已解决. findbugs-maven-plugin:x.x.x:check​ maven编译过程中有可能会出现findbugs-maven-plugin:x.x.x:check报错,这是由于ODL项目默认继承了findbugs插件来检查工程可能出现的一些错误,我们编写的代码不符合插件规则就会报错,解决办法是:在…\\impl\\pom.xml文件中把findbugs-maven-plugin插件改为false,已解决. mininet连不上karaf 在使用mininet配合实验的过程中,出现了在mininet能ping通宿主机的情况下无法连接到控制器的问题.经过分析,应该是使用项目原型模板生成的空项目骨架,不具备连接交换机的能力,需要找到ODL有关这一部分的代码依赖进来,controller\\archetype下的模板都试过了,效果相同,暂未解决 projectstructure有误​ 某些xxx.java文件比如LLDP2ControllerProvider不能正确被IDEA识别，一般的解决方法有,推荐由上至下排查: 检查用IDEA打开项目时,是否打开的是跟.idea文件夹并列的项目,有时上层文件夹跟项目名一致,会出现打开错误 进入File-Project Structure-Modules重新设置一下包的mark 重启IDEA，然后重新编译安装项目 重启IDEA，使用maven-Reload All Maven Projects 清掉后台所有内容，重启电脑","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"}]},{"title":"OpenDayLight学习笔记","slug":"OpenDayLight学习笔记","date":"2022-08-09T11:03:33.833Z","updated":"2022-09-01T01:41:52.823Z","comments":true,"path":"2022/08/09/OpenDayLight学习笔记/","link":"","permalink":"http://example.com/2022/08/09/OpenDayLight%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"​ 本文记录了OpenDayLight的学习过程。","text":"​ 本文记录了OpenDayLight的学习过程。 工程名字按照建立顺序命名，规则为Project+名称+序号，使用大驼峰模式。例如：ProjectTest1； 参考文献 OpenDaylight应用开发–基础篇 OpenDaylight应用开发–提高篇 [ODL技术内幕：架构设计与实现原理](D:\\a研究生资料\\研二\\OpenDayLight\\ODL技术内幕：架构设计与实现原理 (耿兴元) (z-lib.org).epub) Maven仓库搜索(一) Maven仓库搜索(二) 官方Github 基于Oxygen-SR4的ODL框架搭建与开发 官方不同版本的对应关系(不全) 来源网络——ODL浅析 2016年SDNLAB十大热门原创文章 软件环境 java version “1.8.0_202” Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537) 其它：Postman、VMware、Intellij Idea、cmd、mininet、ovs… 获取OpenDayLight项目源码 下载openflowplugin.zip，在父pom文件下安装到本地,需要联网,非常依赖版本关系,目前已知的是钠版本的openflowplugin可以顺利编译通过l2switch的master分支可以编过 mvn -T 1C clean install -DskipTests -Dskip.karaf.featureTest=true -Dmaven.test.skip=true -Dcheckstyle.skip=true -Dmaven.javadoc.skip=true -Dmaven.compile.fork=true mvn clean install -DskipTests -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -e 新建OpenDayLight项目骨架参考文献 ODL官方开发指导文档 标准流程​ 这里总结了建立ODL项目骨架的标准流程,主要是两条构建命令(1.生成骨架;2.安装到本地),还深入研究了一下获取构建原型的网址和原理. 向标准maven的settings.xml添加odlparent settings.xml内容,添加后的内容为settings-标准版添加odlparentsettings内容.xml; 要为OpenDaylight版本找到正确的项目原型版本Archetype-Version，请在https://nexus.opendaylight.org中keyword搜索opendaylight-startup-archetype,得到两个结果: ​ ODL官方认为项目原型应该使用archetypes而不是controller,但是controller仍然在更新,并且最近更新时间在archetypes之后,而且我认为项目原型不应该和版本有明确的强关联,关联关系应该由pom文件手动配置,controller中包的readme内容如下, The org.opendaylight.controller:opendaylight-startup-archetype has been replaced by the org.opendaylight.archetypes:opendaylight-startup-archetype (note how the archetypeGroupId does not contain \"controller\" anymore, but ends with \".archetypes\"),and has a different version now. ​ archetypes下的版本号如下图: 在E:\\SDN\\OpenDayLight\\ProjectTest1进入cmd，生成项目骨架，建议使用第一种，第二种在运行karaf时会产生环境错误: //按网络教程使用controller原型 mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype -DarchetypeRepository=http://nexus.opendaylight.org/content/repositories/public/ -DarchetypeCatalog=remote -DarchetypeVersion=1.5.1 //按官方说明,使用archetypes原型,且不使用snapshot版本 mvn archetype:generate -DarchetypeGroupId=org.opendaylight.archetypes -DarchetypeArtifactId=opendaylight-startup-archetype -DarchetypeRepository=https://nexus.opendaylight.org/content/repositories/opendaylight.release/-DarchetypeCatalog=remote -DarchetypeVersion=1.2.2 填写项目信息，填写不当可能导致莫名错误： copyright：版权方，填公司名称，不能数字开头，s401； copyrightYear、version：默认； groupId：团队名称，建议小驼峰模式； artifactId：项目名，建议小驼峰模式； package、classPrefix：包名、类前缀，建议默认，尤其是classPrefix。 项目文件夹名字为artifactId，进入…\\artifactId运行cmd，安装项目到本地: mvn clean install -DskipTests -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -e 第一个项目：Helloworld参考文献 枫零NET的教程; u_hcy2000的博客 三、OpenDaylight应用基础开发（ODL的Hello World）; 耿兴元老师OpenDaylight应用开发–基础篇; 建立项目ProjectHelloworld1​ 从无到有生成一个标准的ODL项目，体验一个简单ODL功能的实现，熟悉ODL的框架，对ODL有个基本的认识。 按照标准构建流程生成项目骨架、填写项目信息并安装到本地 功能实现 定义YANG文件: 在&#x2F;api&#x2F;src&#x2F;main&#x2F;yang下helloworld.yang文件module{}中添加: rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greeting &#123; type string; &#125; &#125; &#125; 重新安装项目到本地,上述yang模型会在api&#x2F;target&#x2F;generated-sources&#x2F;mdsal-binding&#x2F;org.opendaylight.yang. gen.v1.utn.opendaylight.params.xml.ns.yang.&lt;项目名&gt;.rev&lt;数字&gt;下生成数个类和接口. 进入impl&#x2F;src&#x2F;main&#x2F;java&#x2F;networkGroup&#x2F;impl&#x2F;HelloworldProvider.java下实现代码; 进入impl&#x2F;src&#x2F;main&#x2F;resources&#x2F;org&#x2F;opendaylight&#x2F;blueprint&#x2F;impl-blueprint.xml,在&lt;blueprint&gt;&lt;/blueprint&gt;中添加&lt;odl:rpc-implementation ref=&quot;provider&quot;/&gt;; 重新安装项目,运行E:\\SDN\\OpenDayLight\\ProjectHelloworld1\\helloworld\\karaf\\target\\assembly\\bin\\karaf.bat; 使用Postman，POST方式调用 http://localhost:8181/restconf/operations/helloworld:hello-world； 项目分析​ Helloworld作为OpenDayLight入门的第一个项目，使用了RPC机制来实现功能，需要理解的内容包括： YANG模型和自动生成的工具类、工具接口的对应关系: 是哪些代码实现了读取数据和发送数据的: blueprint是OSGI规范的一部分,ODL使用Apache Blueprint，是XML文件。 元素 作用 bean 描述创建Java实例的元素，可以指定实例初始化的类名、构造方法、构造方法的入参及属性 service 将bean发布为OSGi Service reference 通过接口名引用一个OSGi Service，可以指定一个特定的属性过滤器 reference-list 通过接口名引用多个OSGi Service，可以指定一个特定的属性过滤器 Global RPC、Routed RPC、Notification的订阅、注册、获取都在blueprint操作。 RPC：Remote Procedure Call基本概念 RPC有两类：Global RPC和Routed RPC 类别 区别 Global RPC 一个节点上只有一个RPC实例会被调用，注册多个实例时第一个注册的生效 Routed RPC 通过不同的RoutedId可以调用不同的RPC实例 如何理解ODL中的RPC：异步的响应模式，单播关系 编程实战LLDP2Controller​ 基于项目ProjectHelloworld1通过RPC调用openflowplugin项目提供的下发流表功能实现上送LLDP报文到控制器的操作，该功能涉及配置POM文件、获取RPC、注册RPC、配合mininet验证等内容,在Helloworld项目基础上实现.通过调用别的项目定义好的rpc，是不是就不用自己定义yang文件了？ 把openflowplugin项目依赖进来,在impl&#x2F;pom.xml下&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;中指定openflowplugin-artifacts的版本号，这里选择了跟课程相近的版本 &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>openflowplugin-artifacts&lt;/artifactId> &lt;version>0.6.1&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> 通过blueprint调用SalFlowService中的add-flow rpc,Global RPC和Routed RPC的获取方式相同： //都是用rpc-service标签 //add-flow rpc找到了,但是为什么调用Id是\"flowService\"?找不到? &lt;odl:rpc-service id=\"flowService\" interface=\"org.opendaylight.yang.gen.v1.urn.opendaylight.flow.service.rev130819.SalFlowService\"/> 建立一个新的bean,规定类的组成：类名字、初始化函数、关闭函数: &lt;bean id=\"LLDPToControllerFlowWriter\" class=\"networkGroup.impl.LLDPToControllerFlowWriter\" init-method=\"init\" destroy-method=\"close\"> &lt;argument ref=\"dataBroker\" /> &lt;argument ref=\"flowService\" /> &lt;/bean> 在impl&#x2F;pom.xml下&lt;dependencies&gt;&lt;/dependencies&gt;添加依赖，这里就是实际引入LLDP2Controller所依赖的代码，版本按照&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;中声明的 &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>openflowplugin-api&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>openflowplugin-common&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.opendaylight.controller.model&lt;/groupId> &lt;artifactId>model-inventory&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin.model&lt;/groupId> &lt;artifactId>model-flow-service&lt;/artifactId> &lt;/dependency> 在impl下新建java类.LLDPToControllerFlowWriter，实现相关代码，具体代码见工程文件。 maven编译，安装到本地，成功！ 先启动karaf.bat,再启动mininet，搭建一个简单树形拓扑用于测试,添加-v debug帮助排故 sudo mn --controller=remote,ip=192.168.43.254,port=6633 --topo=tree,2 --switch ovsk,protocols=OpenFlow13 又出现了成功生成karaf后不能连接mininet的情况, ​ 初步估计是对openflowpugin的依赖不正确,缺少控制器与交换机连接的代码,经过测试版本号0.6.0\\0.6.1可以编译通过,但是0.7.x\\0.11.x编译不通过,而且提示代码有问题,有待进一步排查.尝试向工程引入odl-openflowplugin-flow-services-rest,但是版本0.6.0\\0.6.1\\0.7.1均不能编译通过。 &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>odl-openflowplugin-flow-services-rest&lt;/artifactId> &lt;version>0.7.1&lt;/version> &lt;/dependency> 未解决… Ping Hosts​ 新建项目ProjectPingHosts1实现Ping Hosts功能. 编写yang文件,该文件定义了实现Ping Hosts功能的输入与输出格式和内容: module ping &#123; namespace \"urn:opendaylight:ping\"; prefix ping; import ietf-inet-types &#123; prefix \"inet\"; revision-date 2013-07-15; &#125; revision \"2017-08-26\" &#123; description \"TCP ping module\"; &#125; rpc ping-hosts &#123; description \"Send TCP ECHO request\"; input &#123; leaf async &#123; type boolean; &#125; list destination-all &#123; leaf destination &#123; type inet:ipv4-address; &#125; &#125; &#125; output &#123; list echo-result-all &#123; leaf destination &#123; type inet:ipv4-address; &#125; leaf echo-result &#123; type enumeration &#123; enum \"reachable\" &#123; value 0; description \"Received reply\"; &#125; enum \"unreachable\" &#123; value 1; description \"No reply during timeout\"; &#125; enum \"error\" &#123; value 2; description \"Error happened\"; &#125; &#125; description \"Result types\"; &#125; &#125; &#125; &#125; &#125; 由于导入了其它module,需要引入对应的依赖,否者会报bug,然后编译安装到本地: //bug内容: Cannot resolve QNameModule for 'inet' [at D:\\...] //解决措施:在...\\pingHosts\\api\\pom.xml中&lt;dependencies> &lt;/dependencies>添加依赖 &lt;dependency> &lt;groupId>org.opendaylight.mdsal.model&lt;/groupId> &lt;artifactId>ietf-inet-types-2013-07-15&lt;/artifactId> &lt;version>1.2.2-Carbon&lt;/version> &lt;/dependency> 实现功能代码,见项目文件 向impl-blueprint.xml中进行注册: &lt;odl:rpc-implementation ref=\"provider\" /> Notification基础概念 如何理解ODL中的Notification：提供者把消息发送给所有订阅该消息的消费者，组播关系 Notification的配置：Notification使用了”Disruptor”队列,所以初始化要配置队列,ODL没有这个配置文件,需要自己创建 //depth:队列的大小,必须设置为2^n,一般是业务量的二倍 //spin time:死循环时间 //park time:等待时间 &lt;cm:property-placeholder persistent-id=\"org.opendaylight.mdsal.dom.notification\" update-strategy=\"none\"> &lt;cm:default-properties> &lt;cm:property name=\"notification-queue-depth\" value=\"65536\"/> &lt;cm:property name=\"notification-queue-spin\" value=\"0\"/> &lt;cm:property name=\"notification-queue-park\" value=\"0\"/> &lt;/cm:default-properties> &lt;/cm:property-placeholder> 如何发布一条Notification //订阅服务接口 //xml中的封闭元素? &lt;reference id=\"notificationService\" interface=\"org.opendaylight.controller.md.sal.binding.api.NotificationPublishService\"/> /*在需要使用的bean中引用该服务,再通过进一步编程实现发布Notification的功能*/ &lt;argument ref=\"notificationProviderService\" /> //调用方法发布Notification //把消息放到队列中,如果队列满了会抛异常 void putNotification(Notification notification) ； //等待队列有空闲再把消息放到队列 ListenableFuture&lt;?> offerNotification(Notification notification); //在超时时间内,等待队列有空闲再把消息放到队列,如果时间到了还没有空闲就抛出异常 ListenableFuture&lt;?> offerNotification(Notification notification, int timeout, TimeUnit unit)； //这样是发布Notification嘛:registerNotificationListener this.listenerRegistrations.add(notificationService.registerNotificationListener(addressObserverUsingArp)); 如何订阅一条Notification ​ 先在YANG文件中定义一个Notification,然后编译通过YANGTools生成Listener接口,实现接口方法,然后在blueprint中注册.例如: //定义YANG notification toasterOutOfBread &#123;&#125; notification toasterRestocked &#123; leaf amountOfBread &#123; type uint32; &#125; &#125; //生成接口 public interface ToasterListener extends NotificationListener &#123; void onToasterOutOfBread(ToasterOutOfBread notification); void onToasterRestocked(ToasterRestocked notification); &#125; //注册:先用bean实例化方法类,再用 odl:notification-listener 注册类 &lt;bean id=\"kitchenService\" class=\"org.opendaylight.controller.sample.kitchen.impl.KitchenServiceImpl\" init-method=\"register\" destroy-method=\"unregister\"> &lt;argument ref=\"toasterService\"/> &lt;/bean> &lt;odl:notification-listener ref=\"kitchenService\"/> 编程实践​ 新建项目ProjectNotification1,尝试使用archetypes原型(失败). 注册监听OpenFlow的PacketIn消息，收到消息后打印消息类型 /*先实现一个可以处理PacketIn消息的类*/ public class PacketInHandler implements PacketProcessingListener &#123; private static final Logger LOG = LoggerFactory.getLogger(PacketInHandler.class); @Override public void onPacketReceived(PacketReceived notification) &#123; LOG.info(\"收到PacketIn消息\"+notification.toString()); &#125; &#125; /*用bean元素描述这个类,还都是封闭元素*/ &lt;bean id=\"packetInHandler\" class=\"networkGroup.impl.PacketInHandler\"/> /*监听注册*/ &lt;odl:notification-listener ref=\"packetInHandler\"/> 用Yang定义一个notification Java代码实现Yang notification生成的Listener接口 写代码构造notification消息并发布notification Datastore基本概念 Datastore：ODL的内存数据库，其存储的数据结构是由YANG定义的树状的结构，包括基于事务的访问与操作、支持数据变更通知、支持事务链等 Data Tree：所用和状态有关的数据都被建模和表示为Data Tree,Data Tree可以定位到任何元素或子树，Data Tree有两种：Operational Data Tree和Configuration Data Tree(数据树和配置树) Operational Data Tree：报告整个系统的状态，是基于MD-SAL发布的 Configuration Data Tree：由用户填充的系统的预期状态 Instance Identifier：树上某个节点的唯一标识 Transaction(事务)：MD-SAL数据代理(DataBroker)提供的基于事务的对Data Tree的访问 访问Datastore DataBroker：理解为数据代理，是OSGi的一个服务，通过Data Broker可以读写数据库 &lt;reference id=\"dataBroker\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\" odl:type=\"default\" /> DataBroker服务接口: public interface DataBroker extends DataTreeChangeService &#123; /*创建读写等事务的方法:只读\\读写\\只写*/ ReadOnlyTransaction newReadOnlyTransaction(); ReadWriteTransaction newReadWriteTransaction(); WriteTransaction newWriteOnlyTransaction(); /*创建事务链的方法*/ BindingTransactionChain createTransactionChain(TransactionChainListener listener); &#125; /*监听数据变更,注册DataTreeListener方法*/ public interface DataTreeChangeService &#123; ListenerRegistration&lt;L> registerDataTreeChangeListener(@Nonnull DataTreeIdentifier&lt;T> treeId, @Nonnull L listener); &#125; public interface ReadOnlyTransaction &#123; /*Optional&lt;T>类型帮助判断是否读到数据了*/ CheckedFuture&lt;Optional&lt;T>> read(LogicalDatastoreType store, InstanceIdentifier&lt;T> path); @Override void close(); &#125; public interface WriteTransaction &#123; &lt;T extends DataObject> void put(LogicalDatastoreType store, InstanceIdentifier&lt;T> path, T data); &lt;T extends DataObject> void merge(LogicalDatastoreType store, InstanceIdentifier&lt;T> path, T data); &lt;T extends DataObject> void merge(LogicalDatastoreType store, InstanceIdentifier&lt;T> path, T data,boolean createMissingParents); @Override void delete(LogicalDatastoreType store, InstanceIdentifier&lt;?> path); boolean cancel(); CheckedFuture&lt;Void,TransactionCommitFailedException> submit(); &#125; DataChangeEvent(数据变更通知): /*注册监听器,说明要监听哪一个节点*/ ListenerRegistration&lt;L> registerDataTreeChangeListener(@Nonnull DataTreeIdentifier&lt;T> treeId, @Nonnull L listener); /*处理变更通知*/ public interface org.opendaylight.mdsal.binding.api. DataTreeChangeListener &#123; void onDataTreeChanged(@Nonnull Collection&lt;DataTreeModification&lt;T>> changes); &#125; //DataChangeListener已经被社区废弃 TransactionChain(事务链):实际操作中,写数据后立刻读取刚写入的数据不一定保证能得到正确的结果,因为有些是异步的操作,因此,事务链的初衷就是保证事务链里的事务按序提交,让每个事务可以看到前面的事务的操作结果.事务链不能保证事务链里的一连串事务的原子性,但是事务会按照提交的顺序被尽快提交 //DataBroker： @Override /*创建事务链*/ BindingTransactionChain createTransactionChain(TransactionChainListener listener); public interface BindingTransactionChain &#123; @Override /*创建读事务方法*/ ReadTransaction newReadOnlyTransaction(); @Override /*创建写事务方法*/ WriteTransaction newWriteOnlyTransaction(); &#125; ODL集群与分布式基本概念 集群：多个节点执行相同的任务，这些节点就是集群 分布式：将一个任务分布到不同的节点完成，这些节点协同工作、相互依赖，就构成了分布式 硬件要素：节点(逻辑实体,进程\\程序之类)和网络 软件要素: 要素 作用 分片 分布式的数据不可能在一个节点上,如何平衡多个节点的数据分发问题 一致性 相关连的数据之间的逻辑关系是否正确和完整，数据本身是否正确 可用性 每一个操作都能在一定时间内返回结果(备份\\保护\\可靠) 分区容忍性 分布式中不可能所有节点都能时时连通,必须考虑局部失联的情况 CAP 一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)三个要素互相牵制，不可能同时满足 ODL分布式集群的初衷与动机:Scalability(扩展性)、Performance(性能)、High Availablity(高可用) AKKa Akka框架基本要点介绍 AKKa:ODL构建集群的基础,一种程序框架\\工具集,基于JVM运行,可以用Java开发 Actor模型: AKKa组件: Datastore 和 rpc能够跨节点使用,notification不行 搭建ODL集群 手动配置 脚本配置 向ODL中添加Features添加Features流程 添加前查询相关features: 添加位置： 添加格式： &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>features-openflowplugin&lt;/artifactId> &lt;version>0.6.1&lt;/version> &lt;type>xml&lt;/type> &lt;classifier>features&lt;/classifier> &lt;/dependency> 添加、编译后: 如何理解项目的feature模块结构 解析——来源网络 如何知道应该引用哪些features 用mvn dependency:tree可以明确梳理项目模块依赖关系，尤其是查看版本 控制器连接交换机的功能需要features-openflowplugin： &lt;dependency> &lt;groupId>org.opendaylight.openflowplugin&lt;/groupId> &lt;artifactId>features-openflowplugin&lt;/artifactId> &lt;version>0.6.1&lt;/version> &lt;type>xml&lt;/type> &lt;classifier>features&lt;/classifier> &lt;/dependency> features-l2switch： &lt;dependency> &lt;groupId>org.opendaylight.l2switch&lt;/groupId> &lt;artifactId>features-l2switch&lt;/artifactId> &lt;version>0.6.0&lt;/version> &lt;scope>runtime&lt;/scope> &lt;type>xml&lt;/type> &lt;classifier>features&lt;/classifier> &lt;/dependency> RESTCONF协议在sal-rest-connector组件实现,使用odl-restconf-all加载,但是不含数据结构,例如使用OpenFlow结构就要加载odl-flow-model和odl-flow-services. … 添加YANGMAN helloworld项目中在features&#x2F;odl-artifactid-rest&#x2F;pom.xml中添加 &lt;dependency> &lt;groupId>org.opendaylight.dluxapps&lt;/groupId> &lt;artifactId>odl-dluxapps-yangman&lt;/artifactId> &lt;version>0.7.1&lt;/version> &lt;type>xml&lt;/type> &lt;classifier>features&lt;/classifier> &lt;/dependency> 简单综合案例:学生管理参考文献 基于Oxygen-SR4的ODL框架搭建与开发 ODL官方Controller文档 ODL官方开发指导文档 boron源码中的sample例子 osgi-blueprint 技术要点 远程调用:rpc 数据库:datastore 数据监听:datachangelistener 通知与订阅:notification ODL源码tipsslf4j（Simple Logging Facade for Java） 不是具体的日志系统，而是为某个日志系统提供服务，它不影响最终用户选择哪种日志系统，方便在不懂代码的情况下切换日志框架 核心是一些API和LoggerFactory类，它本身也带有一个简单的日志框架 简单会用即可 序列化反序列化 序列化： 将数据结构或对象转换成二进制字节流的过程 反序列化：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程 需要通过网络传输对象、存储到文件、存储到数据库的时候需要序列化&#x2F;反序列化 JDK 自带的序列化，只需实现 java.io.Serializable接口即可(性能较差,但是ODL部分类使用了该接口) hashCode() hashCode就是对象的散列码，是根据对象的某些信息推导出的一个整数值，默认情况下表示是对象的存储地址。通过散列码，可以提高检索的效率，主要用于在散列存储结构中快速确定对象的存储地址 和equals()、toString()可以看做Java类的标配 字段（Field） java反射– Field 用法实践 简单理解就是：我们可用通过Field类对类或对象的field进行动态操作 **field在ODL\\Java中的作用是什么?**SDN更换报文字段的功能是否是基于Field实现的？ FlowBuilder org.opendaylight.yang.gen.v1.urn.opendaylight.flow.inventory.rev130819.tables.table下的类,功能是构建流表Flow openflow1.3流表项构成: public class FlowBuilder implements Builder&lt;Flow> &#123; private Long _bufferId; private String _containerName; //由控制器选择的不透明数据值。控制器用来过滤流统计数据、流改变和流删除,但处理数据包时不能使用 private FlowCookie _cookie; private FlowCookie _cookieMask;//?? private FlowModFlags _flags; private String _flowName; private Integer _hardTimeout; //硬超时时间 private FlowId _id; private Integer _idleTimeout; //空闲超时时间 private Instructions _instructions; //指令集,动作或流水线处理 private FlowKey _key; private Match _match; private Long _outGroup; private BigInteger _outPort; private Integer _priority; private Short _tableId; private Boolean _barrier; private Boolean _installHw; private Boolean _strict; OpenFlow协议超时机制简介: 硬超时hard timeout:当该流表项的存在时间超过了预设置的硬超时，流表项就会被交换机从流表中移除。即流表项从交换机移除的绝对时间 空闲超时idle timeout:如果连续idle timeout时间内都没有匹配到这条流表,则交换机会主动将该流表项从流表中移除 MatchBuilder org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow用于构建匹配字段 openflow1.3支持的匹配字段包括: Future和ListenableFuture Future是Java中的一个类,具体的作用是接受多线程的执行结果,确保得到的执行结果在使用之前进过检验； ListenableFuture是对java原生Future的扩展增强，帮我们检测Future是否完成了，如果完成了就自动调用回调函数，这样可以减少并发程序的复杂度 PacketProcessingListener openflowplugin定义的处理PacketIn消息的封装 intern() 方法 返回字符串对象的规范化表示形式。 项目研究L2Switch基础概念 项目目的：基于MD-SAL架构实现基本的2层交换功能,包括对早先版本的重构,适合学习MD-SAL架构 参考文献: L2switch源码分析（上） L2switch源码分析（下） 项目模块： 模块名 作用 Packet Handler 解码上送到控制器的报文并正确分发 Loop Remover 消除网络中的环路 Arp Handler 处理ARP报文 Address Tracker 学习网络中设备的IP地址和MAC地址,把地址存入datastore中inventory对应节点 Host Tracker 跟踪网络中的主机的拓扑位置 L2Switch Main 根据网络流量下发流表,依赖于上边模块的处理结果 Address Tracker(未改动)/*AddressObservationWriter:根据索引NodeConnectorRef添加mac地址和ip地址*/ public void addAddress(MacAddress macAddress, IpAddress ipAddress, NodeConnectorRef nodeConnectorRef) &#123; return; &#125; /*AddressObserverUsingArp:处理收到的ARP包,校验后调用addressObservationWriter.addAddress写入*/ public void onArpPacketReceived(ArpPacketReceived packetReceived) &#123; RawPacketFields rawPacket = null; EthernetPacket ethernetPacket = null; ArpPacket arpPacket = null; addressObservationWriter.addAddress(ethernetPacket.getSourceMac(), IpAddressBuilder.getDefaultInstance(arpPacket.getSourceProtocolAddress()), rawPacket.getIngress()); &#125; /*AddressObserverUsingIpv4:处理IPv4包*/ /*AddressObserverUsingIpv6:处理IPv6包*/ /*AddressTrackerProvider:一般是AddressTracker模块的入口,初始化该模块的功能,初始化过程在Init()中,这个模块涉及notification的发布\\侦听*/ Arp Handler(未改动)​ 项目中由于系统的ip\\mac相对变化不大,所以实际项目中不太需要处理ARP,使用的相关逻辑是私有的,不是标准的,保留这个模块是为以后做准备(删除或扩展).这里最重要的是inventory.InventoryReader方法,私有的处理datastore的方法就是根据它改的,加了功能和过滤. package 内容 core ArpHandlerProvider\\ ArpPacketHandler\\ PacketDispatcher\\ ProactiveFloodFlowWriter flow InitialFlowWriter inventory InventoryReader core: /**ArpHandlerProvider:初始化ArpHandler模块(入口),关闭ArpHandler模块 主要关注Init(),这里判断了ARP是Proactive模式还是Reactive模式(主动与被动模式) Proactive模式主动下发洪泛ARP的流表,Reactive模式下发把ARP报文上送至控制器的流表 前者调用 ProactiveFloodFlowWriter 后者调用InitialFlowWriter 再创建好读datastore、分发包、处理包、notification等对象*/ /**ArpPacketHandler:处理送上来的ARP报文 类成员包括一个PacketDispatcher的对象,用来发包 主要成员方法是*/ public void onArpPacketReceived(ArpPacketReceived packetReceived) &#123; //收到的包经过校验计算、处理后,调用PacketDispatcher把包发出去 packetDispatcher.dispatchPacket(packetReceived.getPayload(), rawPacket.getIngress(), ethernetPacket.getSourceMac(), ethernetPacket.getDestinationMac()); &#125; /**PacketDispatcher:把包发送出去,作为一个功能类定义了几个成员方法,典型的有*/ //把来自ingress节点的载荷payload发出去,按照源mac和目的mac的关系,调用洪泛或单播方法 public void dispatchPacket(byte[] payload, NodeConnectorRef ingress, MacAddress srcMac, MacAddress destMac) &#123; &#125; /**ProactiveFloodFlowWriter:用于L2Switch的proactive模式。在这种模式下， 造成洪泛的流表自动写入每个交换机，发送到控制器的(traffic)流量更少。*/ flow: /**InitialFlowWriter:给所有交换机下发将ARP数据包发送到控制器的流表, 与core.ProactiveFloodFlowWriter相对,有新交换机上线时会自动识别并下发*/ inventory： /**InventoryReader:用于读datastore数据 详解见packethandler.xx.control.inventory.InventoryReader*/ Host Tracker(有小改动)主机上线,处理,完成之后把结果告诉私有模块. Packet Handler(主要功能)​ Packet Handler负责处理控制器涉及的大部分报文,私有功能的逻辑主要在这里定义.相比标准结构,增加了control、icfp两个文件夹,共有decoder(解码器)文件夹和PacketHandlerProvider类,重点关注control和icfp文件夹,以及私有项目对blueprint的改动,对pom.xml文件的改动. decoder(未改动): package\\class 作用 utils 解码器的工具包 AbstractPacketDecoder 解码抽象类，所有解码器必须继承实现其中方法 ArpDecoder 解码ARP报文 EthernetDecoder 解码以太网帧 IcmpDecoder 解码Icmp报文 Ipv4Decoder 解码Ipv4报文 Ipv6Decoder 解码Ipv6报文,在私有系统中暂时不涉及 PacketHandlerProvider（未改动）：/**PacketHandlerProvider:模块的入口*/ public class PacketHandlerProvider &#123; private static final Logger LOG = LoggerFactory.getLogger(PacketHandlerProvider.class); //不可变集合ImmutableSet ImmutableSet&lt;AbstractPacketDecoder> decoders; //引入Notification服务,在blueprint中引入,是否实现Notification功能,后续实现 private final NotificationProviderService notificationService; //构造器,有参 public PacketHandlerProvider(final NotificationProviderService notificationService) &#123; this.notificationService = notificationService; &#125; //初始化模块,new一堆解码器 public void initiateDecoders() &#123; decoders = new ImmutableSet.Builder&lt;AbstractPacketDecoder>() .add(new EthernetDecoder(notificationService)) .add(new ArpDecoder(notificationService)).add(new Ipv4Decoder(notificationService)) .add(new Ipv6Decoder(notificationService)).add(new IcmpDecoder(notificationService)).build(); LOG.info(\"PacketHandler initialized.\"); &#125; //侦测有解码器对象在,遍历关闭 public void closeDecoders() throws Exception &#123; if (decoders != null &amp;&amp; !decoders.isEmpty()) &#123; for (AbstractPacketDecoder decoder : decoders) &#123; decoder.close(); &#125; &#125; LOG.info(\"PacketHandler (instance &#123;&#125;) torn down.\", this); &#125; &#125; blueprint:packet-handler.xml&lt;!--标准l2switch中的blueprint很简洁,类只注册了入口PacketHandlerProvider,服务只引入了notificationService--> &lt;reference id=\"notificationService\" interface=\"org.opendaylight.controller.sal.binding.api.NotificationProviderService\" /> &lt;bean id=\"packetHandler\" class=\"org.opendaylight.l2switch.packethandler.PacketHandlerProvider\" init-method=\"initiateDecoders\" destroy-method=\"closeDecoders\"> &lt;argument ref=\"notificationService\" /> &lt;/bean> &lt;!--私有项目中对应的blueprint由于增加了功能,注册了新的类,引入了新的服务,略写列在下面--> &lt;reference id=\"dataBroker\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\"odl:type=\"default\" /> &lt;odl:rpc-service id=\"salFlowService\" interface=\"org.opendaylight.yang.gen.v1.urn.opendaylight.flow.service.rev130819.SalFlowService\"/> &lt;odl:rpc-service id=\"packetHandlerService\" interface=\"org.opendaylight.yang.gen.v1.urn.opendaylight.packet.service.rev130709.PacketProcessingService\"/> &lt;bean>ControlServiceIml&lt;/bean> &lt;bean>MyOdlProvider&lt;/bean> pom.xml:增加了依赖项​ 增加了依赖项,主要是openflowplugin、snmp、json等方面. control(增加): package\\class 作用 config 存放系统的配置,提供三种配置Link、Node、Rule，以集合的形式存在总配置对象ConfObject中 entity(实例) 类似于工具类,放了一些功能的实例类,但是大部分代码由于各种原因已经不适用了,保留是因为还没来得及删除或留待以后拓展 flow 包括下发流表的单例,创建\\下发控制器到控制器的初始流表 inventory 保存信息,创建保存信息的数据结构,以及读取ODL内存的功能类 listener 创建了各种消息的侦听器 pathfinding processer service util ControlProvider CustomPacketDispatch 自定义的分发包方法 /**Conf:*/ /**在三种配置的上层,建立了三个集合存放不同的配置对象*/ public class ConfObject&#123; public int outer_dpid=-1;//初始化值,-1无效 public List&lt;LinkConfInfo> link=new ArrayList&lt;>();//存放连接配置 public String controller; public HashMap&lt;String,NodeConfInfo> nodeConfInfo=new HashMap&lt;>();//存放节点配置 public List&lt;RuleConfInfo> rules=new ArrayList&lt;>();//存放规则配置 &#125; /**下面三类配置类都比较简单,就是成员变量+构造器*/ public class LinkConfInfo&#123; public int port; public String type; public String channel; public int interval;//端口之间同步的间隔 /**构造器*/ &#125; public class NodeConfInfo&#123; public String node_level; public String node_num; /**构造器*/ &#125; /**所谓规则Rule就是从这个口到那个口\\这个地址到那个地址走哪个信道?优先级多少?之类的可配置的选项*/ public class RuleConfInfo&#123; public String source_ip; public String source_mac; public int des_port_num; public int protocol_type; public int priority; public int channel; /**构造器*/ &#125; /**entity: ------flow:早期用于下流表的代码,由于改需求已经不用了,暂时没删除,供参考 ------highlight:控制拓扑有流量时高亮功能的代码,,现在是由自己的前端控制,已经不用了,供参考 ------host:存放外网交换机的dpid和mac,包括源和目的,暂时用不上 ------internal:处理车内终端和链接状态 ------multicast:(多播) ------path:包括路径对象,和路径的配置等等 ------rule:现在用其他方法配规则,已经不用了 ------Narrowband.java(窄带):读窄带端机的信息,ip\\掩码\\下一跳等 */ /**flow:包含4*xx.java*/ //自定义动作项 public class CustomActionItem&#123; public int out_put; /**构造器*/ &#125; //自定义匹配项 public class CustomMatchItem&#123; public String s_ip; public String d_ip; public String s_mac; public String d_mac; public int protocol_num = -1; public int l4_source_num= -1; public int l4_destination_num = -1; /**标准配置*/ toString(); equals(); hashCode(); /**构造器*/ &#125; //说明了一条流表的基本状态 public class FlowObject&#123; public FlowStatus flowStatus; public boolean chao_duan_bo=false; public List&lt;Path> in_car_paths=new ArrayList&lt;>();//车内路径 public List&lt;Path> external_paths=new ArrayList&lt;>();//车间路径 public boolean onSameCar=false; public int onSameCar_dpid = -1; //每个交换机对应一个Action列表 public HashMap&lt;Integer,List&lt;CustomActionItem>>action_map=new HashMap&lt;>(); public List&lt;Integer> rule_list=new ArrayList&lt;>(); public void clear()&#123;&#125; &#125; // public enum FlowStatus&#123; NO_ARP,//无arp响应 NO_BETWEEN_PATH,//无车间路径 IN_CAR_FLOW,//车内的流表 BETWEEN_FLOW//车间的流表 &#125; /**flow: ----FlowWriter.java:下发流表的功能类,调用salFlowService服务，包括创建、下发、删除流表、创建动作和指令等 ----InitialC2CFlowWriter.java:创建系统启动时下发的流表,C2C:一个控制器到另一个控制器 */ public class FlowWriter&#123; //成员对象 private static final FlowWriter instance=new FlowWriter();//饿汉单例,别人不能new它,只能调用它 private SalFlowService salFlowService ; //构造器 private FlowWriter()&#123;&#125;//饿汉单例 //getter setter方法 //成员方法 addFlow();/**包括:_inCar,_CHAODUANBO,_multicast,SegmentedPath(分段路径), */ createFlow();/**包括:CHAODUANBO,_multicast,remove*/ removeFlow();/***/ createInstructions();/***/ createAction();/**SetFieldDestinationMacAddress,OutPut,*/ getmaskIP();//处理掩码和IP &#125; public class InitialC2CFlowWriter implements DataTreeChangeListener&lt;node>&#123; //成员对象 private static final String FLOW_ID_PREFIX= \"l2switch-\"; private static final int C2C_ETHER_TYPE=2320;//私有的以太网类型,0x0910 private final ExecutorService initialFlowExecutor=Executors.newCachedThreadPool(); private final SalFlowService salFlowService ; private short flowTableId=0; private int flowPriority = 100; private int flowIdleTimeout = 0; private int flowHardTimeout = 0; private final AtomicLong flowIdInc=new AtomicLong(); private final AtomicLong flowCookieInc=new AtomicLong(0x2b0000000000000L); //构造器 public InitialC2CFlowWriter(SalFlowService salFlowService ); //成员方法 onDataTreeChanged(Collection&lt;DataTreeModification&lt;Node>> changes) ; //内部成员类 public class InitialFlowWriterProcessor implements Runnable&#123; addInitialFlows(); getTableInstanceId(); getFlowInstanceId(); createControllerToControllerFlow(); createDefaultFlow(); getSendToControllerAction(); writeFlowToController(); &#125; &#125; /**inventory: ------FlowDB: 保存路径,包括源和目的在同一台车或不在同一台车,由于改需求,已经不用了,不需要保存路径了 ------InternalDB:给一台车本身的大部分配置都建好集合,从配置文件或其它渠道拿到数据后再存到里面 ------InventoryReader:参考arphandler.inventory.InventoryReader写的读取ODL内存的功能类,还命名为InventoryReader,变化不大 ------RuleDB:保存规则,配置信息等,现在已经不用这种方式配置规则了,只保留了ALL_CHANNEL_LIST,写死5种信道 */ /**FlowDB: */ public class FlowDB&#123; //源和目的在同一台车,保存转发端口就可以 updateInCarFlowMap_SameCar(int dpid,String s_ip,String d_ip,int output_port); //源和目的不在一个车内,需要保存路径计算的结果,就是一个List集合 updateInCarFlowMap_Path(String s_ip,String d_ip,List&lt;Path> paths); &#125; /**InternalDB: */ public class InternalDB&#123; /**成员对象*/ //new一个空的配置对象 public static ConfObject confObject = null; //外部交换机的dpid public static int EXT_SWITCH_DPID = -1; public static HashMap&lt;Integer,Boolean> EXT_NODE_PORT_STATUS=new HashMap&lt;>(); //网关 //车间连接端口:从配置文件中读取车是通过哪些端口连起来的 //端机MAC: //窄带端机都挂载在哪个交换机下面 //有哪些车内交换机:内网\\外网交换机都读 //车内主机mac: //本车交换机mac: //本车的角色配置: &#125; /**InventoryReader: */ public class InventoryReader implements DataTreeChangeListener&lt;DataObject>&#123; /**成员对象*/ private static final Logger LOG=LoggerFactory.getLogger(InventoryReader.class); private final Databroker databroker; private final HashMap&lt;String,List&lt;NodeConnectorRef>> controllerSwitchConnectors; private final HashMap&lt;String,List&lt;NodeConnectorRef>> switchNodeConnectors; private final List&lt;Registration> listenerRegistrationList = new CopyOnWriteArrayList&lt;>(); private volatile boolean refreshData = false;//使用volatile关键字会强制将修改的值立即写入主存,任意线程修改了这个值,对其它线程立即可见 private final long refreshDataDelay = 20L; private volatile boolean refreshDataScheduled = false; private final ScheduledExecutorService nodeConnectorDataChangeEventProcessor=Executors.newScheduledThreadPool(1); /**构造器*/ /**getter、setter方法*/ public void setRefreshData(boolean refreshData); /**成员方法*/ public void registerAsDataChangeListener(); public void onDataTreeChanged(); public void close(); //读取data tree以查找有关节点node和节点连接器NodeConnectors的信息。为给定交换机创建NodeConnector的List集合。还确定每个NodeConnector的STP状态。 public void readInventory(); &#125; /**RuleDB: */ public class RuleDB&#123; /**成员对象*/ public static List&lt;Integer> ALL_CHANNEL_LIST = Stream.of(4,3,2,1,0).collect(Collectors.toList()); &#125; /**listener: ------ARPlistener: ------C2CPacketListener: ------HostInfoListener: ------LldpListener: ------SegmentedPathCalculationListener: ------TopoChangeNotificationListener: */ /**ARPlistener: */ /**pathfinding: ------ ------ */ /**processor： ------ ------- */ /**service: ------ ------ ------ */ /**util: ------ ------ ------ ------ ------ */ /**ControlProvider: */ public class ControlProvider&#123; /**成员对象*/ private final DataBroker dataService； private final SalFlowService salFlowService； private final NotificationProviderService notificationService； private final PacketProcessingService packetProcessingService； public static int PATH_MODE = 1；//0:源节点计算整条路径 1:各节点分别计算 //多态写法 private Registration initialFlowWriterListenerReg; private Registration arpHandlerRegistration; private Registration unicastArpHandlerRegistration; private Registration ipv4HandlerRegistration; private Registration c2cListenerRegistration; private Registration lldpListenerRegistration; private Registration segmentedPathProcessorRegistration; private Registration icfpListenerReg; public static Icfpv2Target icfpv2Target; /**构造器*/ /**成员方法*/ //从文件中读取系统配置 public void readconf()&#123; &#125; public void init() throws IOException&#123;&#125; &#125; /**CustomPacketDispatcher: 自定义的分发包方法,不同需求的发包方法都定义在这 */ public class CustomPacketDispatcher&#123; /**成员对象*/ private InventoryReader inventoryReader; private PacketProcessingService packetProcessingService; /**getter,setter方法*/ /**没写构造器,默认是无参构造器*/ /**成员方法*/ //发送包，调用了底层的TransmitPacketInput，以及Future public void sendPacketOut(byte[] payload,NodeConnectorRef ingress,NodeConnectorRef egress)； public void sendData2Port(byte[] data,String node_id,int outport_port); public void floodArpRequest(String s_ip,String d_ip,String s_mac,NodeConnectorRef nodeConnectorRef); public void sendArpRequest(String s_ip,String d_ip,String s_mac,String nodeId,List&lt;InternalLink> links,NodeConnectorRef origIngress,boolean external); &#125; icfp(增加): package\\class 作用 icsp igmp master timer utils Openflowplugin OpenflowPlugin源码分析(一至八) Bug收集不同package下同名方法供需错误​ 在ODL中，由于版本更迭，许多不同名字的package中包括了相同名字的方法，在导入ODL包的过程中就有可能出现下图的错误，简单解释就是这里需要白字package中的方法（Required type）但是我们却导入了红字package中的方法（Provided）;唯一的解决办法:就是把涉及的package梳理清楚，把引用关系对应上，在LLDP2Controller实验中出现了这个错误,已解决. findbugs-maven-plugin:x.x.x:check​ maven编译过程中有可能会出现findbugs-maven-plugin:x.x.x:check报错,这是由于ODL项目默认继承了findbugs插件来检查工程可能出现的一些错误,我们编写的代码不符合插件规则就会报错,解决办法是:在…\\impl\\pom.xml文件中把findbugs-maven-plugin插件改为false,已解决. mininet连不上karaf 在使用mininet配合实验的过程中,出现了在mininet能ping通宿主机的情况下无法连接到控制器的问题.经过分析,应该是使用项目原型模板生成的空项目骨架,不具备连接交换机的能力,需要找到ODL有关这一部分的代码依赖进来,controller\\archetype下的模板都试过了,效果相同,暂未解决 projectstructure有误​ 某些xxx.java文件比如LLDP2ControllerProvider不能正确被IDEA识别，一般的解决方法有,推荐由上至下排查: 检查用IDEA打开项目时,是否打开的是跟.idea文件夹并列的项目,有时上层文件夹跟项目名一致,会出现打开错误 进入File-Project Structure-Modules重新设置一下包的mark 重启IDEA，然后重新编译安装项目 重启IDEA，使用maven-Reload All Maven Projects 清掉后台所有内容，重启电脑 ​","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"ODL","slug":"ODL","permalink":"http://example.com/tags/ODL/"}]},{"title":"工具Utils","slug":"工具Utils","date":"2022-08-09T10:48:22.391Z","updated":"2022-08-26T11:20:41.454Z","comments":true,"path":"2022/08/09/工具Utils/","link":"","permalink":"http://example.com/2022/08/09/%E5%B7%A5%E5%85%B7Utils/","excerpt":"​ 本文记录了软件学习过程中用到的工具类知识点，比如数据交换格式、软件安装、环境配置、辅助工具等。","text":"​ 本文记录了软件学习过程中用到的工具类知识点，比如数据交换格式、软件安装、环境配置、辅助工具等。 JSON [[图灵程序设计丛书].JSON必知必会](https://pan.baidu.com/s/1UoHP8BiumEt70aSVyhv7dQ提取码：3ir5 )：基础语法1-4章 XML [XML入门经典（第5版）](https://pan.baidu.com/s/1l8uOjScZA3tFntH4UTZi-A提取码：gmy9 )基础语法：2-4章 [XML基础教程（第二版）](https://pan.baidu.com/s/1PLCv0MfDOhE7eYo9OXAykg提取码：qqxx [) W3school:xml XML 教程 &lt;!--xml序言+独立声明-->&lt;!--注意linux还是Windows格式的换行符--> &lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> &lt;!--创建元素的方式--> &lt;!--标准元素,有内容--> &lt;myelement>code&lt;/myelement> &lt;!--自封闭元素,没有内容--> &lt;myelement/> &lt;!--四种命名方式--> &lt;!--大驼峰--> &lt;MyElement/> &lt;!--小驼峰--> &lt;myElement/> &lt;!--下划线--> &lt;my_element/> &lt;!--连字符--> &lt;my-element/> &lt;!--一个文档只能有一个根元素--> &lt;root> &lt;!--元素中可以添加属性:属性就是(名称-值)--> &lt;myelement myfirstattribute=\"one\" mysecondattribute='two' mythirdattribute=' '>&lt;/myelement> &lt;!--元素和属性均可包括文本--> &lt;myelement>Here is a test&lt;/myelement> &lt;!--元素和属性都可以用来包装数据--> &lt;!--元素--> &lt;user> &lt;firstname>Yu-Ang&lt;/firstname> &lt;lastname>ZHU&lt;/lastname> &lt;/user> &lt;!--属性--> &lt;user firstname=\"Yu-Ang\" lastname=\"ZHU\" /> &lt;user firstname=\"Yu-Ang\" lastname=\"ZHU\">&lt;/user> &lt;!--处理指令--> &lt;?xml-stylesheet type=\"text/xsl\" href=\"appUsers.xslt\"?> &lt;!--CDATA节,允许在xml文件中插入纯文本--> &lt;!--格式: &lt;![CDATA[文本内容]]> --> &lt;user> &lt;![CDATA[这里写的内容会被当做纯文本处理]]> &lt;/user> &lt;!--通过向元素中添加特殊的属性来决定如何处理空白符--> &lt;!--保留空白符--> &lt;user xml:space=\"preserve\"/> &lt;!--默认处理空白符--> &lt;user xml:space=\"default\"/> &lt;!--命名空间：理解为Java中的package,大小写敏感--> &lt;!--命名空间：建议使用URL或者URN命名规范，这两个合称URI--> &lt;!--URL--> [Scheme]://[Domain][:Port]/[Path]?[QueryString]#[FragmentId] &lt;!--URN--> urn:[namespace identifier]:[namespace specific string] &lt;!--声明命名空间的方法一：默认命名空间,希望整个文档都属于这个空间--> &lt;root xmlns = \"http://wrox.com/namespace/app/config\"> &lt;firstname>Yu-Ang&lt;/firstname> &lt;lastname>ZHU&lt;/lastname> &lt;/root> &lt;!--root元素中的所有子元素都属于这个命名空间,但是属性不属于这个空间--> &lt;!--即:默认命名空间仅针对元素--> &lt;!--给属性分配命名空间需要显示定义,即前缀名,声明命名空间的方法二--> &lt;!--给命名空间一个前缀名xx,并且把元素分配给该空间--> &lt;xx:user xmlns:xx = \"http://wrox.com/namespace/app/config/xx\"> &lt;firstname>Yu-Ang&lt;/firstname> &lt;lastname>ZHU&lt;/lastname> &lt;/xx:user> &lt;!--把属性也分配给命名空间--> &lt;user xx:firstname=\"Yu-Ang\" xx:lastname=\"ZHU\" /> &lt;user xx:firstname=\"Yu-Ang\" xx:lastname=\"ZHU\">&lt;/user> &lt;!--使用&#123;URI&#125;+元素名唯一标记一个元素--> &#123;http://wrox.com/namespace/app/config&#125;root &lt;/root> blueprint blueprint是OSGi框架的一部分,使用xml,管理模块的加载、依赖、配置等(blueprint的配置介绍) 标准buleprint的标签: 元素 作用 bean 描述创建Java实例的元素，可以指定实例初始化的类名，构造方法，构造方法的入参及属性 reference 通过接口名引用一个OSGi service，可以指定一个特定的属性过滤器 reference-list 通过接口名引用多个 OSGi services ，可以指定一个特定的属性过滤器 service 把bean发布为OSGi service property 属性? argument 拓展ODL的XML配置语法,可以为某节点增加可选节点 &lt;!--根元素是blueprint,元素可以是标准元素也可以是封闭元素--> &lt;blueprint xmlns=命名空间 xmlns:xx=前缀 属性=属性 > &lt;bean id=\"provider\" class=\"networkGroup.impl.HelloworldProvider\" init-method=\"init\" destroy-method=\"close\"> &lt;argument ref=\"dataBroker\" /> &lt;/bean> &lt;reference id=\"dataBroker\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\" odl:type=\"default\" /> &lt;service ref=\"domRpcRouter\" odl:type=\"default\"> &lt;interfaces> &lt;value>org.opendaylight.controller.md.sal.binding.api.DataBroker&lt;/value> &lt;value>org.opendaylight.controller.md.sal.binding.api.DataBroker&lt;/value> &lt;/interfaces> &lt;/service> &lt;service ref = \"domMountPointService\" interface=\"org.opendaylight.controller.md.sal.binding.api.DataBroker\" odl:type=\"default\"/> &lt;/blueprint> ODL对blueprint进行了拓展controller&#x2F;opendaylight&#x2F;blueprint: 元素 作用 odl:type 对于一个接口有多个实现的，odl:type可以用来确定某个具体实现 odl:rpc-implementation Global RPC注册 odl:routed-rpc-implementation Routed RPC的注册 odl:rpc-service Global RPC和Routed RPC的获取 odl:notification-listener NotificationListenser的注册,订阅者 odl:clustered-app-config 通过ODL的datastore实现集群内的全局配置,比较复杂 odl:default-config ? &lt;service ref=\"domRpcRouter\" odl:type=\"default\"> &lt;odl:rpc-implementation ref=\"fooRpcService\"/> &lt;odl:routed-rpc-implementation id=\"fooRoutedRpcServiceReg\" ref=\"fooRoutedRpcService\"/> &lt;odl:rpc-service id=\"fooRpcService\" interface=\"org.opendaylight.app.FooRpcService\"/> &lt;odl:notification-listener ref=\"fooListener\"/> &lt;odl:clustered-app-config id=\"myConfig\" binding-class=\"org.opendaylight.yang.gen.v1.urn.opendaylight.myapp.config.rev160624.MyConfig\"> &lt;/odl:clustered-app-config> blueprint配置要点: 配置注入的变量名在类定义中，首字母一定要小写，不能大写！！ 使用blueprint配置后，pom中不能有Bundle-Activator配置 两个Blueprint配置文件中的服务不能相互依赖 Maven [动力节点：maven入门](https://pan.baidu.com/s/10avLNviwoYM7id_1OAQwPQ提取码：y6no [) 动力节点：maven视频 &lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;: ​ 该元素被用于管理依赖版本号，通常会在一个组织或者项目的最顶层的父POM中看到，这样后续的依赖、子项目就可以不指定版本号，更新版本号时也在这里更新就好了，但是该元素不实现引入,子项目需要显示的声明需要用的依赖。如果子项目声明了版本号，那么优先使用子项目的。 mvn dependency:tree：梳理项目依赖关系 VMware-Network VMware虚拟机网络模式介绍 VMware自身有三块虚拟网卡，分别对应三种网卡模式： 安装 VMware会在宿主机形成两种网卡，VMware Network Adapter VMnet1和VMware Network Adapter VMnet8，由于本机还安装了VirtualBox以及微软的一些服务，ipconfig查出来的信息有时不叫这两个名字，有可能叫本地连接* 1只要按规则配置能用就不用管 桥接模式：VMWare虚拟机的网卡和宿主机的物理网卡都连接在虚拟交换机VMent0上，因此虚拟机网卡和宿主机网卡需要在同一网段才能通信，如果有多个虚拟机，它们相当于多个和宿主机平等的主机真实的接入VMent0 //虚拟机配置ip方式 //1.进入系统配置文件 vim /etc/network/interfaces //2. 编辑网卡信息 //目前只开了桥接网卡,ip写死 # interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback #auto ens38 #iface ens38 inet dhcp #iface ens38 inet static #address 171.10.0.17 #netmask 255.255.255.0 auto ens33 iface ens33 inet static address 192.168.0.11 netmask 255.255.255.0 //3.配置网段后重启网络服务,可ping同宿主机 sudo service networking restart //4.也可以用ifconfig,一般是单次生效 //配某网卡的 ip、掩码 ifconfig eth1 192.168.x.x netmask 255.255.255.0 //配网关 route add default gw 192.168.x.254 NAT模式:NAT模式下主机更像是虚拟机们的路由器,理解为主机是虚拟机的”上级”，NAT模式下的虚拟机时通过真实宿主机的ip访问外网 仅主机模式：仅主机模式下的虚拟机不具有联网能力，只能和宿主机通信 总结： 模式 特点 用途 桥接 虚拟机和宿主机都有独立的IP，处于平等地位接在虚拟交换机上，需要位于同网段才能通信 实验最常使用的配置模式，在许多场合下保持虚拟机、宿主机互相ping通即可 仅主机 无论虚拟机IP怎么配，其本身不能上网，仅能和宿主机通信 辅助模式，和桥接模式配合让虚拟机、宿主机ping通 NAT 宿主机相当于虚拟机的上级，虚拟机使用宿主机的IP上网 一般不使用，使用虚拟机工作的时候最方便，不用额外配置虚拟机网卡 Karaf​ ODL使用Karaf容器发布控制器,有必要了解Karaf的基本用法 ODL中的Karaf命令使用: //安装features feature:install odl-restconf odl-l2switch-switch-ui //如果要重新安装feature，请logout退出，清空安装目录下的data文件夹，再./karaf clean //善用TAB键补足命令 //搜索关键字op feature:list|grep op bundle:list|grep op IDEA .idea：存放项目的配置信息，包括历史记录，版本控制信息等 .iml: 代码注解、jar依赖的索引文件 对IDEA project structure的理解 导入或打开某个项目时,要打开跟.idea文件并列的那个项目,否则projectstructure报错 对IDEA maven工具中各选项的理解 ODL ODL的总体架构改变的话，升第一个版本号，集成并更新功能，正式发布一个版本升第二个版本号，只是在某个正式发布版本的基础上修改bug，升第三个版本号 生成的项目骨架只有yang和md-sal的基础功能，不含任何业务 ,要增加features才能连接mininet 如何查找某个端口号是否被监听,例如查找6633 /**win11 cmd*/ netstat -an | findstr 6633 /**其他,待验证*/ netstat -an | grep 6633 DNS DNS:Domain Name system,域名解析协议 常见用法: /**进行DNS查询*/ nslookup /**查看DNS缓存*/ ipconfig /displayDNS /**清空DNS缓存*/ ipconfig/flushDNS 常用公用DNS服务器:114.114.114.114&#x2F;223.5.5.5 操作系统 查看ubuntu虚拟机防火墙是否开启: sudo ufw status 查看ARP /*查看arp缓存*/ arp -a /*清空arp缓存*/ arp -d netty netty in action 推荐阅读","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"}]},{"title":"YANG语言","slug":"YANG语言","date":"2022-08-09T10:48:22.389Z","updated":"2022-08-26T08:05:45.525Z","comments":true,"path":"2022/08/09/YANG语言/","link":"","permalink":"http://example.com/2022/08/09/YANG%E8%AF%AD%E8%A8%80/","excerpt":"​ 本文记录了学习SDN过程中涉及的YANG语言的知识点,以及ODL是如何使用YANG语言的.","text":"​ 本文记录了学习SDN过程中涉及的YANG语言的知识点,以及ODL是如何使用YANG语言的. 参考文献 RFC6020 - YANG语言标准中文 ODL技术内幕：架构设计与实现原理 Restful和Restconf REST（Representational State Transfer，表述性状态转移）是一种软件设计风格，不是一个标准，许多web是基于REST风格设计的。（1.资源静态，动作清晰；2.无状态设计；3.前后端分离API；） Restful接口是遵循REST设计风格的接口，没有标准要求； Restconf接口是既遵循REST设计风格，又遵循IETF制定的RFC8040标准的接口，有明确的定义和设计规范，基于HTTP协议，用于访问YANG语言定义的数据。比Netconf语言简洁、灵活。 YANG基础概念 schema tree:模式树,data tree:数据树; 专门用于描述数据的语言; YANG语言使用module\\submodule构建数据模型; 树形结构; ODL用YANG抽象数据模型,包括项目YANGTools等; 基础语法注释Comments 单行注释开始于“&#x2F;&#x2F;”，结束于本行。块注释开始于“&#x2F;*”，结束于“ *&#x2F;”,跟C++风格一样 定义module和submodule 一个module能包含任意数量的submodules，但是每个submodule只能属于一个module moudle还包含一些命名空间、前缀 //这些是module的基本信息,包括import的其它module,本module的版本、修改时间、简称的前缀等 module sal-flow &#123; namespace \"urn:opendaylight:flow:service\"; prefix flow; import yang-ext &#123;prefix ext; revision-date \"2013-07-09\";&#125; import opendaylight-inventory &#123;prefix inv;revision-date \"2013-08-19\";&#125; import opendaylight-flow-types &#123;prefix types;revision-date \"2013-10-26\";&#125; import opendaylight-group-types &#123;prefix group-type;revision-date \"2013-10-18\";&#125; import opendaylight-meter-types &#123;prefix meter-type;revision-date \"2013-09-18\";&#125; import flow-capable-transaction &#123;prefix tr; revision-date \"2015-03-04\";&#125; import flow-errors &#123;prefix error; revision-date \"2013-11-16\";&#125; description \"Openflow flow management.\"; revision \"2013-08-19\" &#123; description \"Initial revision of flow service\"; &#125; 枚举类型enumeration//例子1 type enumeration &#123; enum 10m; enum 100m; enum auto; &#125; //例子2 leaf echo-result &#123; type enumeration &#123; enum \"reachable\" &#123; value 0; description \"Received reply\"; &#125; enum \"unreachable\" &#123; value 1; description \"No reply during timeout\"; &#125; enum \"error\" &#123; value 2; description \"Error happened\"; &#125; &#125; description \"Result types\"; &#125; YANG四种节点类型 leaf：只能包含一个值，没有子节点； //一个名字叫host-name的leaf类型的节点 //节点包含string类型的数据 //描述信息是\"Hostname for this system\" leaf host-name &#123; type string; //必选 description \"Hostname for this system\"; &#125; leaf-list：一系列的leaf节点； //一系列leaf节点,这些节点都是用来domain-search的 //节点都包含string类型数据 //相当于数组 leaf-list domain-search &#123; type string; description \"List of domain names to search\"; &#125; container:没有值,专门用于把相关的节点归纳到一个subtree下面,可以包括任何类型\\任何数量子节点: //container类型的system节点包含container类型的login节点 //container类型的login节点把leaf类型 message节点组成了一棵子树 container system &#123; container login &#123; leaf message &#123; type string; description\"Message given at start of login session\"; &#125; &#125; &#125; list:由一个key的leaf节点唯一确定,能定义多种key leafs,能包含任意类型\\任意数目子节点: //名为user的list,由名为name的leaf节点唯一确定 //user里面还包括其他leaf list user &#123; key \"name\"; leaf name &#123; type string; &#125; leaf full-name &#123; type string; &#125; leaf class &#123; type string; &#125; &#125; 上述四种节点可以组成简单的示例module: // Contents of \\\"acme-system.yang\\\" module acme-system &#123; namespace \\\"http://acme.example.com/system\\\"; prefix \\\"acme\\\"; organization \\\"ACME Inc.\\\"; contact \\\"joe@acme.example.com\\\"; description \\\"The module for entities implementing the ACME system.\\\"; revision 2007-06-09 &#123; description \\\"Initial revision.\\\"; &#125; container system &#123; leaf host-name &#123; type string; description \\\"Hostname for this system\\\"; &#125; leaf-list domain-search &#123; type string; description \\\"List of domain names to search\\\"; &#125; container login &#123; leaf message &#123; type string; description\"Message given at start of login session\\\"; &#125; list user &#123; key \\\"name\\\"; leaf name &#123; type string; &#125; leaf full-name &#123; type string; &#125; leaf class &#123; type string; &#125; &#125; &#125; &#125; &#125; YANG定义RPC(Remote Procedure Call) 定义操作名字，输入参数，和输出参数: //定义远程调用activate-software-image //输入的一个string类型的 image-name //期望得到一个string类型的输出status rpc activate-software-image &#123; input &#123; leaf image-name &#123; type string; &#125; &#125; output &#123; leaf status &#123; type string; &#125; &#125; &#125; Helloworld.yang被解读为： //helloworld模块中定义了一次名为hello-world的rpc调用 //输入是string类型的name //输出是string类型的greeting //能够与Postman请求的结果对应上 module helloworld &#123; yang-version 1.1; namespace \"urn:opendaylight:params:xml:ns:yang:helloworld\"; prefix \"helloworld\"; revision \"2017-08-30\" &#123; // TODO change revision to date of model creation description \"Initial revision of helloworld model\"; &#125; rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greeting &#123; type string; &#125; &#125; &#125; Routed RPC:一定要有input字段,一定要有routed字段,routed字段的根本类型必须是instance-identifier /*yang定义*/ typedef person-ref&#123; type instance-identifier; &#125; identity person-context&#123; description \"ccc\"; &#125; /*定义关键字context-reference,*/ extension \"context-reference\"&#123; argument \"context-type\"; &#125; rpc buy-car&#123; input&#123; leaf person&#123; /**下面两句就是routed字段*/ ext:context-reference \"person-context\"; type person-ref; ... &#125; &#125; &#125; /*注册*/ &lt;odl:routed-rpc-implementation id=\"xxx\" ref=\"zzz\"/> &lt;bean id=\"peopleProvider\" class=\"org.opendaylight.controller.clustering.it.provider.PeopleProvider\"> &lt;property name=\"dataProviser\" ref=\"dataBroker\"/> &lt;property name=\"rpcRegistration\" ref=\"carPurchaseRpcReg\"/> &lt;/bean> /*需要调用rpcRegistration.registerPath(xx.class,personId)*/ YANG定义Notification notifaction是误拼,写文件时千万注意 notification的定义和container\\grouping差不多,不像RPC中有input和output,应该是跟notification的运行机制有关系 notification flow-added &#123; status deprecated; uses tr:transaction-metadata; leaf flow-ref &#123; type types:flow-ref; &#125; uses node-flow; uses tr:transaction-aware; &#125; YANG自定义新类型typedef typedef声明定义了一个新的type， 该自定义type可以在module内部，包含该module的modules或submodules，以及导入该module的其它modules使用 // flow-table-ref 是定义的新类型的名字 typedef flow-table-ref &#123; description \"Openflow table identifier\"; type instance-identifier; // instance-identifier是YANG的基本类型:References a data tree node &#125; 例如inet:port-number\\inet:ip-address都是自定义的类型 可重用节点集合Grouping grouping声明了一个可重用的集合,定以后在引用的位置通过”uses”实例化 //定义名为node-flow-removed的 grouping //里面添加了两个leaf // grouping node-flow-removed &#123; description \"Flow removed message structure.\"; leaf node &#123; // TODO:: replace with inv:node-context-ref ext:context-reference \"inv:node-context\"; type inv:node-ref; &#125; leaf flow-table &#123; type flow-table-ref; &#125; uses types:flow-mod-removed; &#125; //在container中引用grouping container peer &#123; container destination &#123; uses node-flow-removed; &#125; &#125; grouping可以在引用时被重新定义 uses只有一个参数,应该是grouping的名字, //标准用法 type是其他yang文件的简称,以前缀的形式出现 uses types:flow; //参数带双引号是什么意思?grouping名字可以带双引号? uses \"inv:node-context-ref\"; status声明 “status”声明的参数是一个字符串，是“current”，“deprecated”或者“obsolete”中的一个 “current”意味着该定义在当前是有效的 “deprecated”表示该定义已经被废弃，不过保证在暂时在后续的实现中支持该定义，以保证向前兼容 “obsolete”意味着这个定义已经被完全废弃，不应该再使用了 choice与case “choice”和”case”用于声明互不相容不能同时出现的节点，”choice”声明包含了多个”case” 每个”case”声明都可能包含多个节点，但是每个节点都应该只在一个”case”中出现 //可以理解为object-reference中有三个选项 //这三个选项只能选一个,不能同时生效 grouping node-error-reference &#123; description \"Error message binding - to which source type the error belongs.\"; choice object-reference &#123; case flow-ref&#123; leaf flow-ref &#123; type types:flow-ref; &#125; &#125; case group-ref&#123; leaf group-ref &#123; type group-type:group-ref; &#125; &#125; case meter-ref&#123; leaf meter-ref &#123; type meter-type:meter-ref; &#125; &#125; &#125; &#125; include与import include用于引用其他submodule定义的数据 import用于引入其他module定义的数据 include acme-types; import yang-ext &#123;prefix ext; revision-date \"2013-07-09\";&#125; 扩展数据模型(augment) 允许一个模块将额外的节点插入到数据模型中，包括当前的module(以及它的submodule)或者一个外部的module augment定义了在数据模型树形结构中，新的节点插入的位置,when声明了新节点生效的时间。 /*当该node的user的class不等于wheel的时候,把uid节点插到augment声明的位置*/ augment /system/login/user &#123; when \"class != 'wheel\"; leaf uid &#123; type uint16 &#123; range \"1000 .. 30000\"; &#125; &#125; &#125; 语言扩展extension 使用extension可以定义新的关键字,使用的时候需要在引入新关键字的位置带上定义新关键字的module名字 identity声明 用于定义一个新的，全局唯一的，抽象的，没有特定类型的identity 目的就是对外宣示它的名字，语义以及存在,既能够从头开始定义，也能够从一个base identity处继承 identity的参数是一个identifier，就是这个identity的名字 module crypto-base &#123; namespace \"http://example.com/crypto-base\"; prefix \"crypto\"; identity crypto-alg &#123; description \"Base identity from which all crypto algorithms are derived.\"; &#125; &#125; module des &#123; namespace \"http://example.com/des\"; prefix \"des\"; import \"crypto-base\" &#123; prefix \"crypto\"; &#125; identity des &#123; base \"crypto:crypto-alg\"; description \"DES crypto algorithm\"; &#125; identity des3 &#123; base \"crypto:crypto-alg\"; description \"Triple DES crypto algorithm\"; &#125; &#125; YANG在ODL中的实现元素命名QName（Qualified Name，限定名） 来源于XML，格式是命名空间namespace：元素名localName，例：xsl:template ODL类似于XML，但多了revision字段，即namespace、localName和revision（修订版本），其中namespace和revision标识一个YANGmodule，可以分为locallocalName和QNameModule ODL在org.opendaylight.yangtools.yang.common中定义 QName由QName、QNameModule与Revision类组成 QName的比较、创建…. 数据树的索引YangInstanceIdentifier YANG中有instance-identifier用来唯一标识数据树中某个节点,ODL用YangInstanceIdentifier类实现 是一个分层的、基于内容的、唯一的标识符，用来对数据树中数据项的寻址，代表了数据树中某个节点的路径 语法格式使用的是XPath的简化格式的子集,ODL用Path接口表示,org.opendaylight.yangtools.concepts.Path YangInstanceIdentifier类实现Path接口,可以说YangInstance-Identifier类就是表示了数据树中的节点访问路径的定义,org.opendaylight.yangtools.yang.data.api.YangInstanceIdentifier YangInstanceIdentifier由PathArgument(路径的参数)组成,一组有序的PathArgument列表构成一条访问路径 YangInstanceIdentifier的比较、创建…. 数据节点抽象定义NomalizedNode NormalizedNode类作为所有数据节点的基础抽象,即定义一个通用的接口来统一表示上述YANG节点类型","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"YANG","slug":"YANG","permalink":"http://example.com/tags/YANG/"}]}],"categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"},{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Openflowplugin","slug":"Openflowplugin","permalink":"http://example.com/tags/Openflowplugin/"},{"name":"L2switch","slug":"L2switch","permalink":"http://example.com/tags/L2switch/"},{"name":"Bug","slug":"Bug","permalink":"http://example.com/tags/Bug/"},{"name":"ODL","slug":"ODL","permalink":"http://example.com/tags/ODL/"},{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"},{"name":"YANG","slug":"YANG","permalink":"http://example.com/tags/YANG/"}]}