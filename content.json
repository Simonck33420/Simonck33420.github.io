{"meta":{"title":"SDN BOLG","subtitle":"","description":"","author":"Simonck","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-08-09T08:05:36.000Z","updated":"2022-08-09T08:06:51.099Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-09T08:05:27.000Z","updated":"2022-08-09T08:07:11.738Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"工具Utils","slug":"工具Utils","date":"2022-08-09T10:48:22.391Z","updated":"2022-08-09T08:34:27.989Z","comments":true,"path":"2022/08/09/工具Utils/","link":"","permalink":"http://example.com/2022/08/09/%E5%B7%A5%E5%85%B7Utils/","excerpt":"​ 本文记录了软件学习过程中用到的工具类知识点，比如数据交换格式、软件安装、环境配置等。","text":"​ 本文记录了软件学习过程中用到的工具类知识点，比如数据交换格式、软件安装、环境配置等。 JSON [[图灵程序设计丛书].JSON必知必会](https://pan.baidu.com/s/1UoHP8BiumEt70aSVyhv7dQ提取码：3ir5 )：基础语法1-4章 XML [XML入门经典（第5版）](https://pan.baidu.com/s/1l8uOjScZA3tFntH4UTZi-A提取码：gmy9 ) [XML基础教程（第二版）](https://pan.baidu.com/s/1PLCv0MfDOhE7eYo9OXAykg提取码：qqxx [) W3school:xml Maven [动力节点：maven入门](https://pan.baidu.com/s/10avLNviwoYM7id_1OAQwPQ提取码：y6no [) 动力节点：maven视频 …","categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"}]},{"title":"YANG语言","slug":"YANG语言","date":"2022-08-09T10:48:22.389Z","updated":"2022-08-09T08:34:35.458Z","comments":true,"path":"2022/08/09/YANG语言/","link":"","permalink":"http://example.com/2022/08/09/YANG%E8%AF%AD%E8%A8%80/","excerpt":"​ 本文记录了学习SDN过程中涉及的YANG语言的知识点。","text":"​ 本文记录了学习SDN过程中涉及的YANG语言的知识点。 Restful和Restconf REST（Representational State Transfer，表述性状态转移）是一种软件设计风格，不是一个标准，许多web是基于REST风格设计的。（1.资源静态，动作清晰；2.无状态设计；3.前后端分离API；） Restful接口是遵循REST设计风格的接口，没有标准要求； Restconf接口是既遵循REST设计风格，又遵循IETF制定的RFC8040标准的接口，有明确的定义和设计规范，基于HTTP协议，用于访问YANG语言定义的数据。比Netconf语言简洁、灵活。 YANG基础概念 schema tree:模式树,data tree:数据树; 专门用于描述数据的语言; YANG语言使用module\\submodule构建数据模型; 树形结构; ODL用YANG抽象数据模型,包括项目YANGTools等; 基础语法YANG有四种数据建模节点类型：leaf、leaf-list、container 、list; leaf：只能包含一个值，没有子节点； 1234567//一个名字叫host-name的leaf类型的节点//节点包含string类型的数据//描述信息是&quot;Hostname for this system&quot;leaf host-name &#123;type string; //必选description &quot;Hostname for this system&quot;;&#125; leaf-list：一系列的leaf节点； 1234567//一系列leaf节点,这些节点都是用来domain-search的 //节点都包含string类型数据 //相当于数组 leaf-list domain-search &#123; type string; description &quot;List of domain names to search&quot;; &#125; container:没有值,专门用于把相关的节点归纳到一个subtree下面,可以包括任何类型\\任何数量子节点: 12345678910//container类型的system节点包含container类型的login节点 //container类型的login节点把leaf类型 message节点组成了一棵子树 container system &#123; container login &#123; leaf message &#123; type string; description&quot;Message given at start of login session&quot;; &#125; &#125; &#125; list:由一个key的leaf节点唯一确定,能定义多种key leafs,能包含任意类型\\任意数目子节点: 1234567891011121314//名为user的list,由名为name的leaf节点唯一确定 //user里面还包括其他leaf list user &#123; key &quot;name&quot;; leaf name &#123; type string; &#125; leaf full-name &#123; type string; &#125; leaf class &#123; type string; &#125; &#125; 上述四种节点可以组成简单的示例module: 12345678910111213141516171819202122232425262728293031323334353637383940// Contents of \\&quot;acme-system.yang\\&quot; module acme-system &#123; namespace \\&quot;http://acme.example.com/system\\&quot;; prefix \\&quot;acme\\&quot;; organization \\&quot;ACME Inc.\\&quot;; contact \\&quot;joe@acme.example.com\\&quot;; description \\&quot;The module for entities implementing the ACME system.\\&quot;; revision 2007-06-09 &#123; description \\&quot;Initial revision.\\&quot;; &#125; container system &#123; leaf host-name &#123; type string; description \\&quot;Hostname for this system\\&quot;; &#125; leaf-list domain-search &#123; type string; description \\&quot;List of domain names to search\\&quot;; &#125; container login &#123; leaf message &#123; type string; description&quot;Message given at start of login session\\&quot;; &#125; list user &#123; key \\&quot;name\\&quot;; leaf name &#123; type string; &#125; leaf full-name &#123; type string; &#125; leaf class &#123; type string; &#125; &#125; &#125; &#125; &#125; YANG能定义RPC(Remote Procedure Call, 远程过程调用); 定义操作名字，输入参数，和输出参数: 123456789101112131415//定义远程调用activate-software-image//输入的一个string类型的 image-name//期望得到一个string类型的输出statusrpc activate-software-image &#123;input &#123;leaf image-name &#123;type string;&#125;&#125;output &#123;leaf status &#123;type string;&#125;&#125;&#125; Helloworld.yang被解读为： 1234567891011121314151617181920212223//helloworld模块中定义了一次名为hello-world的rpc调用//输入是string类型的name//输出是string类型的greeting//能够与Postman请求的结果对应上module helloworld &#123; yang-version 1.1; namespace &quot;urn:opendaylight:params:xml:ns:yang:helloworld&quot;; prefix &quot;helloworld&quot;; revision &quot;2017-08-30&quot; &#123; // TODO change revision to date of model creation description &quot;Initial revision of helloworld model&quot;; &#125; rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greeting &#123; type string; &#125; &#125; &#125; YANG能定义Notification(notifaction是误拼,使用时要注意);* YANG在ODL中的实现元素命名QName（Qualified Name，限定名） 来源于XML，格式是命名空间namespace：元素名localName，例：xsl:template ODL类似于XML，但多了revision字段，即namespace、localName和revision（修订版本），其中namespace和revision标识一个YANGmodule，可以分为locallocalName和QNameModule ODL在org.opendaylight.yangtools.yang.common中定义 QName由QName、QNameModule与Revision类组成 QName的比较、创建…. 数据树的索引YangInstanceIdentifier YANG中有instance-identifier用来唯一标识数据树中某个节点,ODL用YangInstanceIdentifier类实现 是一个分层的、基于内容的、唯一的标识符，用来对数据树中数据项的寻址，代表了数据树中某个节点的路径 语法格式使用的是XPath的简化格式的子集,ODL用Path接口表示,org.opendaylight.yangtools.concepts.Path YangInstanceIdentifier类实现Path接口,可以说YangInstance-Identifier类就是表示了数据树中的节点访问路径的定义,org.opendaylight.yangtools.yang.data.api.YangInstanceIdentifier YangInstanceIdentifier由PathArgument(路径的参数)组成,一组有序的PathArgument列表构成一条访问路径 YangInstanceIdentifier的比较、创建…. 数据节点抽象定义NomalizedNode NormalizedNode类作为所有数据节点的基础抽象,即定义一个通用的接口来统一表示上述YANG节点类型","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"YANG","slug":"YANG","permalink":"http://example.com/tags/YANG/"}]},{"title":"OpenDayLight学习笔记","slug":"OpenDayLight学习笔记","date":"2022-08-09T10:48:22.388Z","updated":"2022-08-09T10:51:25.138Z","comments":true,"path":"2022/08/09/OpenDayLight学习笔记/","link":"","permalink":"http://example.com/2022/08/09/OpenDayLight%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"​ 本文记录了OpenDayLight的学习过程。","text":"​ 本文记录了OpenDayLight的学习过程。 工程名字按照建立顺序命名，规则为Project+名称+序号，使用大驼峰模式。例如：ProjectTest1； 参考文献 OpenDaylight应用开发–基础篇 [ODL技术内幕：架构设计与实现原理](D:\\a研究生资料\\研二\\OpenDayLight\\ODL技术内幕：架构设计与实现原理 (耿兴元) (z-lib.org).epub) Maven仓库搜索(一) Maven仓库搜索(二) 官方Github 获取OpenDayLight项目源码 下载openflowplugin.zip，在父pom文件下安装到本地 新建OpenDayLight项目骨架软件环境 java version “1.8.0_202” Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537) 其它：Postman、VMware、win11、Intellij Idea、cmd… 建空项目 向标准maven的settings.xml添加odlparent settings.xml内容,添加后的内容为settings-标准版添加odlparentsettings内容.xml; 在E:\\SDN\\OpenDayLight\\ProjectTest1进入cmd，生成项目骨架: 1mvn archetype:generate -DarchetypeGroupId=org.opendaylight.controller -DarchetypeArtifactId=opendaylight-startup-archetype -DarchetypeRepository=http://nexus.opendaylight.org/content/repositories/public/ -DarchetypeCatalog=remote -DarchetypeVersion=1.5.1 填写项目信息，填写不当可能导致 Failed to execute goal org.codehaus.mojo:findbugs-maven-plugin:3.0.5:check：错误 copyright：版权方，填公司名称，不能数字开头； copyrightYear、version：默认； groupId：团队名称，建议小驼峰模式； artifactId：项目名，建议小驼峰模式； package、classPrefix：包名、类前缀，建议默认，尤其是classPrefix。 项目文件夹名字为artifactId，进入…\\artifactId运行cmd，安装项目到本地: 1mvn clean install -DskipTests -Dmaven.javadoc.skip=true -Dcheckstyle.skip=true -e 第一个项目：Helloworld参考文献 枫零NET的教程; u_hcy2000的博客 三、OpenDaylight应用基础开发（ODL的Hello World）; 耿兴元老师OpenDaylight应用开发–基础篇; 建立项目ProjectHelloworld1 生成项目骨架、填写项目信息并安装到本地 功能实现 定义YANG文件: 在&#x2F;api&#x2F;src&#x2F;main&#x2F;yang下helloworld.yang文件module{}中添加: 123456789101112rpc hello-world &#123; input &#123; leaf name &#123; type string; &#125; &#125; output &#123; leaf greeting &#123; type string; &#125; &#125;&#125; 重新安装项目到本地,上述yang模型会在api&#x2F;target&#x2F;generated-sources&#x2F;mdsal-binding&#x2F;org.opendaylight.yang. gen.v1.utn.opendaylight.params.xml.ns.yang.&lt;项目名&gt;.rev&lt;数字&gt;下生成数个类和接口. 进入impl&#x2F;src&#x2F;main&#x2F;java&#x2F;networkGroup&#x2F;impl&#x2F;HelloworldProvider.java下实现代码; 进入impl&#x2F;src&#x2F;main&#x2F;resources&#x2F;org&#x2F;opendaylight&#x2F;blueprint&#x2F;impl-blueprint.xml,在&lt;blueprint&gt;&lt;/blueprint&gt;中添加&lt;odl:rpc-implementation ref=&quot;provider&quot;/&gt;; 重新安装项目,运行E:\\SDN\\OpenDayLight\\ProjectHelloworld1\\helloworld\\karaf\\target\\assembly\\bin\\karaf.bat; 使用Postman，POST方式调用 http://localhost:8181/restconf/operations/helloworld:hello-world； 项目分析​ Helloworld作为OpenDayLight入门的第一个项目，使用了RPC机制来实现功能，需要理解的内容包括： YANG模型和自动生成的工具类、工具接口的对应关系: 是哪些代码实现了读取数据和发送数据的: blueprint是OSGI规范的一部分,ODL使用Apache Blueprint，是XML。 元素 作用 bean 描述创建Java实例的元素，可以指定实例初始化的类名、构造方法、构造方法的入参及属性 service 将bean发布为OSGi Service reference 通过接口名引用一个OSGi Service，可以指定一个特定的属性过滤器 reference-list 通过接口名引用多个OSGi Service，可以指定一个特定的属性过滤器 Global RPC、Routed RPC、Notification的订阅、注册、获取都在blueprint操作。 RPC：Remote Procedure Call基本概念 RPC有两类：Global RPC和Routed RPC 类别 区别 Global RPC 一个节点上只有一个RPC实例会被调用，注册多个实例时第一个注册的生效 Routed RPC 通过不同的RoutedId可以调用不同的RPC实例 如何理解ODL中的RPC：异步的响应模式，单播关系 LLDP2Controller​ 想通过RPC调用openflowplugin项目提供的下发流表功能实现上送LLDP报文到控制器的操作，该功能涉及配置POM文件、获取RPC、注册RPC等内容,在Helloworld项目基础上实现. 把openflowplugin项目依赖进来,在impl&#x2F;pom.xml下&lt;dependencyManagement&gt;&lt;/dependencyManagement&gt;中添加openflowplugin-artifacts 1234567&lt;dependency&gt; &lt;groupId&gt;org.opendaylight.openflowplugin&lt;/groupId&gt; &lt;artifactId&gt;openflowplugin-artifacts&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 通过blueprint调用SalFlowService中的add-flow rpc,Global RPC和Routed RPC的获取方式相同： 123//都是用rpc-service标签//add-flow rpc找到了,但是为什么调用Id是&quot;flowService&quot;?找不到?&lt;odl:rpc-service id=&quot;flowService&quot; interface=&quot;org.opendaylight.yang.gen.v1.urn.opendaylight.flow.service.rev130819.SalFlowService&quot;/&gt; 建立一个新的bean,规定类的组成: 123456&lt;bean id=&quot;LLDPToControllerFlowWriter&quot; class=&quot;networkGroup.impl.LLDPToControllerFlowWriter&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt; &lt;argument ref=&quot;dataBroker&quot; /&gt; &lt;argument ref=&quot;flowService&quot; /&gt; &lt;/bean&gt; 在impl&#x2F;pom.xml下&lt;dependencies&gt;&lt;/dependencies&gt;添加bundle依赖 12345678910111213141516 &lt;dependency&gt;&lt;groupId&gt;org.opendaylight.openflowplugin&lt;/groupId&gt; &lt;artifactId&gt;openflowplugin-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.opendaylight.openflowplugin&lt;/groupId&gt; &lt;artifactId&gt;openflowplugin-common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.opendaylight.controller.model&lt;/groupId&gt; &lt;artifactId&gt;model-inventory&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.opendaylight.openflowplugin.model&lt;/groupId&gt; &lt;artifactId&gt;model-flow-service&lt;/artifactId&gt; &lt;/dependency&gt; 在impl下新建java类.LLDPToControllerFlowWriter ​","categories":[{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"ODL","slug":"ODL","permalink":"http://example.com/tags/ODL/"}]}],"categories":[{"name":"工具","slug":"工具","permalink":"http://example.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"SDN","slug":"SDN","permalink":"http://example.com/categories/SDN/"}],"tags":[{"name":"Utils","slug":"Utils","permalink":"http://example.com/tags/Utils/"},{"name":"YANG","slug":"YANG","permalink":"http://example.com/tags/YANG/"},{"name":"ODL","slug":"ODL","permalink":"http://example.com/tags/ODL/"}]}